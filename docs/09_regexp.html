<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>正規表現 :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 9;</script></head>

<article>
<nav><a href="08_error.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="10_modules.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 9</span>正規表現</h1>

<blockquote>

<p><a class="p_ident" id="p_2kuSN7rMzf" href="#p_2kuSN7rMzf" tabindex="-1" role="presentation"></a>ある問題にぶつかったときに、こう考える人がいる。「分かってる、正規表現を使おう。」今や問題は2つだ。</p>

<footer>Jamie Zawinski</footer>

</blockquote>

<blockquote>

<p><a class="p_ident" id="p_vFulIihdz0" href="#p_vFulIihdz0" tabindex="-1" role="presentation"></a>Yuan-Maが言った。「木目に沿って逆らって切ろうとすれば、さらに力が必要じゃ。お主のプログラムが問題の木目に逆らっておれば、より多くのコードが必要じゃ。」</p>

<footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>

</blockquote><figure class="chapter square-framed"><img src="img/chapter_picture_9.jpg" alt="A railroad diagram"></figure>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>プログラミングツールや技術は、カオス的に、進化のように生き延びて増殖していく。素晴らしい技術がいつも勝つとは限らず、ニッチな分野で上手く機能したものや、たまたま他の成功した技術に組み込まれたものが生き延びていく。</p>

<p><a class="p_ident" id="p_EeDCEUkIAR" href="#p_EeDCEUkIAR" tabindex="-1" role="presentation"></a>この章では、そうしたツールの1つ、 <em>正規表現(regular expression)</em> について扱う。正規表現とは、文字列データのパターンを表記する方式だ。正規表現は、JavaScript(や他の言語やシステム)の一部に組み込まれた別の小さい言語のようなものだ。</p>

<p><a class="p_ident" id="p_7mIJI/9fxR" href="#p_7mIJI/9fxR" tabindex="-1" role="presentation"></a>正規表現はひどくわずらわしいけど、とんでもなく便利だ。文法は暗号のようだし、JavaScriptが提供するプログラミングインターフェイスはぎこちないものだ。それでも正規表現は文字列を検査したり生成したりする強力なツールで、きちんと理解すれば君はより効率的なプログラマーになれるだろう。</p>

<h2><a class="h_ident" id="h_09XYO8/Xd8" href="#h_09XYO8/Xd8" tabindex="-1" role="presentation"></a>正規表現の生成</h2>

<p>正規表現はオブジェクトの一種だ。 <code>RegExp</code> コンスラクターで生成するか、スラッシュ( <code>/</code> )文字でパターンを囲むかすればいい。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_O1I2rl+HTy" href="#c_O1I2rl+HTy" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">re1</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">&quot;abc&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">re2</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/</span>;</pre>

<p><a class="p_ident" id="p_az8znGe7A9" href="#p_az8znGe7A9" tabindex="-1" role="presentation"></a>この正規表現オブジェクトはどちらも同じパターンを表している。文字 <em>a</em> に <em>b</em> が続いて、その次に <em>c</em> がくる。</p>

<p><code>RegExp</code> コンストラクターを使うとパターンは普通の文字列として書かれることになる。だからバックスラッシュ()に関するルールもいつも通りだ。</p>

<p>スラッシュの間にパターンを書く2番目の記法では、バックスラッシュの扱いが違う。まず、パターン内にそのままスラッシュを書くと終了と解釈されるから、スラッシュの前にはバックスラッシュを置かないといけない。さらに特別な文字コード( <code>\n</code> のように)の一部ではないバックスラッシュは <em>保存される</em> 。文字列でのようには無視されないで、パターンの意味を変えてしまう。クエスチョンマークやプラス記号には正規表現では特別な意味があるから、その文字自体を表現したい場合には前にバックスラッシュを置かないといけない。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_uRzUiBSrul" href="#c_uRzUiBSrul" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">eighteenPlus</span> <span class="cm-operator">=</span> <span class="cm-string-2">/eighteen\+/</span>;</pre>

<h2><a class="h_ident" id="h_SmcdGEBy3Q" href="#h_SmcdGEBy3Q" tabindex="-1" role="presentation"></a>マッチのテスト</h2>

<p>正規表現オブジェクトにはいくつかのメソッドがある。一番単純なのは <code>test</code> だ。 <code>test</code> に文字列を渡すと、文字列がパターンにマッチするかどうか真偽値で教えてくれる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Szn1CmrIV5" href="#c_Szn1CmrIV5" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;abcde&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;abxde&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_qZk+NkcGgW" href="#p_qZk+NkcGgW" tabindex="-1" role="presentation"></a>特別な記号を含まない正規表現は単に文字の並びを表現するだけだ。もし <em>abc</em> がテストしようとする文字列に含まれていたら(このとき始まりだけとは限らない)、 <code>true</code> が返される。</p>

<h2><a class="h_ident" id="h_1F+QStyA3B" href="#h_1F+QStyA3B" tabindex="-1" role="presentation"></a>文字のセット</h2>

<p>文字列が <em>abc</em> を含むか知りたいだけなら <code>indexOf</code> でも十分だ。正規表現を使えばもっと複雑なパターンを表現できるんだ。</p>

<p>全ての数字に対してマッチさせたいとしよう。正規表現では、角カッコの間に文字のセットを置くと、その部分はセット内のどの文字でもマッチするようになる。</p>

<p><a class="p_ident" id="p_sdV4ERHYT3" href="#p_sdV4ERHYT3" tabindex="-1" role="presentation"></a>次の表現は、どちらも10進数を含む全ての文字列とマッチする。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Z3UJdL//cY" href="#c_Z3UJdL//cY" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0123456789]/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;in 1992&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0-9]/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;in 1992&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_5hECt86hEv" href="#p_5hECt86hEv" tabindex="-1" role="presentation"></a>角カッコの中では、2つの文字とその間のハイフン( <code>-</code> )は、文字の範囲を表現する。ここで、順序は文字のUnicode数で決まる。この順序では0から9までの文字は隣り合っていて(コード48から57)、 <code>[0-9]</code> は全ての10進数にマッチするんだ。</p>

<p><a class="p_ident" id="p_C9mp4xxEGU" href="#p_C9mp4xxEGU" tabindex="-1" role="presentation"></a>一般的によく使われる文字のグループには、ショートカット版の書き方がある。10進数もその1つで、 <code>\d</code> が <code>[0-9]</code> と同じ意味になる。</p>

<table>

<tr><td><code>\d</code></td><td>10進数の文字全て</td>

</tr>

<tr><td><code>\w</code></td><td>英数字 (“単語(word)の文字”)</td>

</tr>

<tr><td><code>\s</code></td><td>全てのホワイトスペース文字 (スペース, タブ, 改行など)</td>

</tr>

<tr><td><code>\D</code></td><td>10進数 <em>ではない</em> もの全て</td>

</tr>

<tr><td><code>\W</code></td><td>英数字ではないもの全て</td>

</tr>

<tr><td><code>\S</code></td><td>ホワイトスペース文字ではないもの全て</td>

</tr>

<tr><td><code>.</code></td><td>改行文字以外の全て</td>

</tr>

</table>

<p><a class="p_ident" id="p_R7LsTWMTK8" href="#p_R7LsTWMTK8" tabindex="-1" role="presentation"></a>これで、01-30-2003 15:20のような日時のフォーマットは、以下のような正規表現でマッチできるはずだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Y0e7M8nAL0" href="#c_Y0e7M8nAL0" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;01-30-2003 15:20&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;30-jan-2003 15:20&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p>ひどい見た目でしょ?パターンの半分がバックスラッシュなのがノイズになって、本当に表現したいパターンを分かりづらくしてしまっている。<a href="09_regexp.html#date_regexp_counted">後で</a>もう少しマシなバージョンを見ていくことにしよう。</p>

<p>このバックスラッシュを使ったコードは、角カッコの中でも使える。例えば、 <code>[\d.]</code> は全ての10進数かピリオドという意味だ。だけどピリオド自体も、角カッコの中では、特別な意味を失うんだ。その他の特別な文字( <code>+</code> など)にも同じことがいえる。</p>

<p>文字のセットを <em>反転させる</em> 、つまりセット <em>以外の</em> 文字にマッチさせたいと表現するには、キャレット( <code>^</code> )文字を開き角カッコの次に書けばいい。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_XH8deAcckk" href="#c_XH8deAcckk" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">notBinary</span> <span class="cm-operator">=</span> <span class="cm-string-2">/[^01]/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;1100100010100110&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;1100100010200110&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<h2><a class="h_ident" id="h_4TyiD/EcbH" href="#h_4TyiD/EcbH" tabindex="-1" role="presentation"></a>部分パターンの繰り返し</h2>

<p><a class="p_ident" id="p_chfZtQL2DE" href="#p_chfZtQL2DE" tabindex="-1" role="presentation"></a>十進数1文字とマッチさせる方法は分かった。整数(つまり1つ以上の10進数文字のシーケンス)とマッチさせたいなら?</p>

<p><a class="p_ident" id="p_pD/MhHwik3" href="#p_pD/MhHwik3" tabindex="-1" role="presentation"></a>正規表現の中でプラス記号( <code>+</code> )を何かの次に置けば、その要素が1回以上表れるという意味になる。つまり、 <code>/\d+/</code> は、1つ以上の十進数文字とマッチするんだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_9/5mFF4Ih4" href="#c_9/5mFF4Ih4" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;'123'&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;''&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;'123'&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;''&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_tlifxqsNyC" href="#p_tlifxqsNyC" tabindex="-1" role="presentation"></a>星( <code>*</code> )も同じような意味を持つけど、こちらはゼロ回でも許容する。星が後ろについたものは、テストする文字列に存在しなくても、パターンがマッチするのを妨げることはないんだ。ただ、マッチするテキストがなければ、0個の文字とマッチするだけだ。</p>

<p><a class="p_ident" id="p_lPCzYnHv+a" href="#p_lPCzYnHv+a" tabindex="-1" role="presentation"></a>クエスチョンマークはパターンの一部を <em>オプション</em> にする。つまり、0回でも1回でも良いということになるんだ。次の例では <em>u</em> 文字は存在してもいいけど、なくてもパターンはマッチする。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EiCIowdq+d" href="#c_EiCIowdq+d" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-operator">=</span> <span class="cm-string-2">/neighbou?r/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;neighbour&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;neighbor&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_Qxu7AWyp2A" href="#p_Qxu7AWyp2A" tabindex="-1" role="presentation"></a>パターンが正確に何回表れるか指定したいなら波カッコを使おう。例えば、ある要素の後に <code>{4}</code> を置けば、4回現れるという意味になる。また、回数の範囲を指定することもできる。 <code>{2,4}</code> はある要素が最低2回、最大4回現れるという意味だ。</p>

<p id="date_regexp_counted"><a class="p_ident" id="p_PCjQN+Ms0w" href="#p_PCjQN+Ms0w" tabindex="-1" role="presentation"></a>以下は、日時のパターンの別のバージョンで、日、月、時が1桁でも2桁でも受け入れる。さらに解読するのも少し簡単になった。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Tw+K6Mxe45" href="#c_Tw+K6Mxe45" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;1-30-2003 8:45&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_rDR41po8gf" href="#p_rDR41po8gf" tabindex="-1" role="presentation"></a>終わりに制限がない範囲を書くこともできる。波カッコの中でコンマの後の数字を省略して、 <code>{5,}</code> のように書けば5回以上という意味になるんだ。</p>

<h2><a class="h_ident" id="h_jLE38Ms1gL" href="#h_jLE38Ms1gL" tabindex="-1" role="presentation"></a>部分表現のグループ化</h2>

<p><a class="p_ident" id="p_5z5wa++8Y+" href="#p_5z5wa++8Y+" tabindex="-1" role="presentation"></a><code>*</code> や <code>+</code> を2つ以上の要素に一度に使いたかったら、カッコで囲めばいい。カッコで囲まれた正規表現は、その後に続く演算子からは1つの要素として扱われるんだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_P/f6a65XwI" href="#c_P/f6a65XwI" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">cartoonCrying</span> <span class="cm-operator">=</span> <span class="cm-string-2">/boo+(hoo+)+/i</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">cartoonCrying</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;Boohoooohoohooo&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_e6Za7n1jp4" href="#p_e6Za7n1jp4" tabindex="-1" role="presentation"></a>1つ目と2つ目の <code>+</code> 文字は、 <em>boo</em> と <em>hoo</em> の2文字目の <em>o</em> だけに作用する。3つ目の <code>+</code> は <code>(hoo+)</code> というグループまるごとに作用して、この並びが1つ以上あればマッチする。</p>

<p><a class="p_ident" id="p_rk8oHfWl0P" href="#p_rk8oHfWl0P" tabindex="-1" role="presentation"></a>この例の最後の <code>i</code> は、正規表現を大文字小文字を区別しないようにする。パターンが全て小文字で書かれていても、大文字の <em>B</em> がマッチするようになるんだ。</p>

<h2><a class="h_ident" id="h_gK3RiBVobR" href="#h_gK3RiBVobR" tabindex="-1" role="presentation"></a>マッチとグループ</h2>

<p><a class="p_ident" id="p_Oa6J4KE1lF" href="#p_Oa6J4KE1lF" tabindex="-1" role="presentation"></a><code>test</code> メソッドは正規表現をマッチさせるには、間違いなく一番単純なやり方だ。ただマッチしたかどうか教えてくれるだけで、それ以外には何もしない。正規表現には <code>exec</code> (execute)メソッドもあって、マッチしなければ <code>null</code> を返し、そうでなければマッチに関する情報を持ったオブジェクトを返す。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JJMWZpk0iD" href="#c_JJMWZpk0iD" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;one two 100&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>);
<span class="cm-comment">// → [&quot;100&quot;]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 8</span></pre>

<p><code>exec</code> が返すオブジェクトは <code>index</code> プロパティを持っていて、成功したマッチが始まった <em>場所</em> を教えてくれる。それを除けば、このオブジェクトは文字列を保持する配列に見える(実際のところ、その通りだ)。この配列の最初の要素はマッチした文字列で、上の例では探していた通り、十進数のシーケンスだった。</p>

<p>文字列値にも同じようにふるまう <code>match</code> メソッドがある。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_uAkAqNYx+q" href="#c_uAkAqNYx+q" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;one two 100&quot;</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/\d+/</span>));
<span class="cm-comment">// → [&quot;100&quot;]</span></pre>

<p><a class="p_ident" id="p_wwW0b1Mdqm" href="#p_wwW0b1Mdqm" tabindex="-1" role="presentation"></a>正規表現がカッコでグループ化された部分表現を持っている場合には、そのグループとマッチしたテキストも、返ってくる配列に含まれる。マッチしたテキスト全体は常に最初の要素になる。2番目の要素は、最初のグループ(開きカッコが正規表現の始めに現れるもの)にマッチした部分で、それから2つ目のグループとマッチしたもの、というように続く。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5E2M1BBsUm" href="#c_5E2M1BBsUm" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">quotedText</span> <span class="cm-operator">=</span> <span class="cm-string-2">/'([^']*)'/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">quotedText</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;she said 'hello'&quot;</span>));
<span class="cm-comment">// → [&quot;'hello'&quot;, &quot;hello&quot;]</span></pre>

<p>あるグループが全くマッチしなかった場合には(例えばクエスチョンマークが付いているとき)、返り値の配列でそのグループが占めるはずの場所には <code>undefined</code> が置かれる。同じように、あるグループが何度もマッチすると、最後のマッチだけが配列に残る。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_j9t+gn+1eT" href="#c_j9t+gn+1eT" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/bad(ly)?/</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;bad&quot;</span>));
<span class="cm-comment">// → [&quot;bad&quot;, undefined]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/(\d)+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;123&quot;</span>));
<span class="cm-comment">// → [&quot;123&quot;, &quot;3&quot;]</span></pre>

<p>グループは文字列の一部を取り出すのに便利だ。例えば文字列が日付を含んでいるかテストするだけではなく、それを取り出して日付のオブジェクトを作りたいなら、十進数のパターンをカッコで囲めば、 <code>exec</code> の結果から日付を直接取り出せる。</p>

<p>でも、その前に少し遠回りをして、日付や時間を表すJavaScriptの組込みオブジェクトについて見てみよう。</p>

<h2><a class="h_ident" id="h_58J8RjR7HI" href="#h_58J8RjR7HI" tabindex="-1" role="presentation"></a>Dateクラス</h2>

<p>JavaScriptには日付を表す(というよりむしろ時間を指す)標準クラスが備わっている。それは <code>Date</code> オブジェクトで、単に <code>new</code> キーワードで呼びだせば現在の日付と時間が得られる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_AjgqFetryg" href="#c_AjgqFetryg" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>());
<span class="cm-comment">// → Mon Nov 13 2017 16:19:11 GMT+0100 (CET)</span></pre>

<p>指定した時間でオブジェクトを作ることもできる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_2VCU0f4HsQ" href="#c_2VCU0f4HsQ" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>));
<span class="cm-comment">// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>, <span class="cm-number">12</span>, <span class="cm-number">59</span>, <span class="cm-number">59</span>, <span class="cm-number">999</span>));
<span class="cm-comment">// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p_Yz13KNNolE" href="#p_Yz13KNNolE" tabindex="-1" role="presentation"></a>JavaScriptでは、月は0からの数で表し(12月は11だ)、日付は1からの数字で表す。これは混乱を招くし、バカげている。気をつけよう。</p>

<p><a class="p_ident" id="p_MRQRpXOQNK" href="#p_MRQRpXOQNK" tabindex="-1" role="presentation"></a>後ろから4つの引数(時、分、秒、ミリ秒)はオプションで、省略すれば0が割当てられる。</p>

<p><a class="p_ident" id="p_Z7ft6fVZs6" href="#p_Z7ft6fVZs6" tabindex="-1" role="presentation"></a>タイプスタンプは協定世界時の1970年の始めから数えたミリ秒の数字として保存される。これはその時代に開発された“Unix time”と呼ばれる習慣に従っている。1970年以前の日時には負の数を使う。 <code>Date</code> オブジェクトの <code>getTime</code> メソッドはこのミリ秒を返す。想像のとおり、大きな数字だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_lMlCuckMIc" href="#c_lMlCuckMIc" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2013</span>, <span class="cm-number">11</span>, <span class="cm-number">19</span>).<span class="cm-property">getTime</span>());
<span class="cm-comment">// → 1387407600000</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">1387407600000</span>));
<span class="cm-comment">// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p_NWoZK3kTsE" href="#p_NWoZK3kTsE" tabindex="-1" role="presentation"></a><code>Date</code> コンストラクターに引数を1つだけ渡した場合には、そうしたミリ秒として扱われる。現在を表すミリ秒を得るには、 <code>Date</code> オブジェクトを作って <code>getTime</code> メソッドを呼び出すか、 <code>Date.now</code> 関数を呼び出すかすればいい。</p>

<p><a class="p_ident" id="p_hc88qHyaE+" href="#p_hc88qHyaE+" tabindex="-1" role="presentation"></a><code>Date</code> オブジェクトから一部を取り出すには <code>getFullYear</code> や <code>getMonth</code> , <code>getDate</code> , <code>getHours</code> , <code>getMinutes</code> そして <code>getSeconds</code> メソッドを使えばいい。 <code>getFullYear</code> だけではなく <code>getYear</code> メソッドも存在していて、これは年から1900を引いた数字(98や119)を返すけど、使い道はほとんどない。</p>

<p>これで、正規表現の一部をカッコで囲んで、文字列からほしい部分を取り出して、 <code>Date</code> オブジェクトを作れるようになった。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xW0xfMnpiZ" href="#c_xW0xfMnpiZ" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">getDate</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">let</span> [<span class="cm-def">_</span>, <span class="cm-def">month</span>, <span class="cm-def">day</span>, <span class="cm-def">year</span>] <span class="cm-operator">=</span>
    <span class="cm-string-2">/(\d{1,2})-(\d{1,2})-(\d{4})/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">string</span>);
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-variable-2">year</span>, <span class="cm-variable-2">month</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>, <span class="cm-variable-2">day</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">getDate</span>(<span class="cm-string">&quot;1-30-2003&quot;</span>));
<span class="cm-comment">// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)</span></pre>

<p>ここで <code>_</code> (アンダースコア)バインディングは無視されている。 <code>exec</code> の返り値の配列から、全体のマッチをスキップするためだけに置かれているんだ。</p>

<h2><a class="h_ident" id="h_UbmXLm8kYt" href="#h_UbmXLm8kYt" tabindex="-1" role="presentation"></a>単語と文字列の境界</h2>

<p><a class="p_ident" id="p_QdTo8t44X5" href="#p_QdTo8t44X5" tabindex="-1" role="presentation"></a>残念ながら、上の <code>getDate</code> 関数は、 <code>&quot;100-1-30000&quot;</code> の文字列から、00-1-3000のようなナンセンスな日付を取り出してしまう。マッチは文字列のどこで起こってもいいから、この場合には2番目の文字から始まって、最後の文字までで終わっている。</p>

<p><a class="p_ident" id="p_rpLkKHVReN" href="#p_rpLkKHVReN" tabindex="-1" role="presentation"></a>マッチが文字列全体をカバーするようにしたいなら <code>^</code> と <code>$</code> を加えればいい。 <code>^</code> は入力文字列の開始に、 <code>$</code> は末尾にマッチする。例えば <code>/^\d+$/</code> は全てが十進数でできた1文字以上の文字列にマッチする。 <code>/^!/</code> は!で始まる全ての文字列にマッチする。 <code>/x^/</code> はどんな文字列にもマッチしない(文字列の始まる前に <em>x</em> が存在することはあり得ないからだ)。</p>

<p>もし日付の始まりと終わりが単語の境界になるようにしたかったら、 <code>\b</code> を使えばいい。これは単語の境界の意味で、文字列のどこでも使えて、片側に単語文字( <code>\w</code> で表されるようなもの)がきて、片側にそれ以外がくるようなパターンにマッチする。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_6U0b866tUk" href="#c_6U0b866tUk" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/cat/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;concatenate&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\bcat\b/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;concatenate&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><code>\b</code> は実際の文字にはマッチしないことに注意しよう。ただ正規表現がある条件に則っている場合だけマッチするように強制するだけだ。</p>

<h2><a class="h_ident" id="h_fGcmLFuG3n" href="#h_fGcmLFuG3n" tabindex="-1" role="presentation"></a>選択パターン</h2>

<p><a class="p_ident" id="p_RPL9YC3XKT" href="#p_RPL9YC3XKT" tabindex="-1" role="presentation"></a>あるテキストが、数字の後に <em>pig</em> , <em>cow</em> , <em>chicken</em> のうちのどれか(もしくはその複数形)が続くパターンを含んでいるか知りたいとしよう。</p>

<p><a class="p_ident" id="p_d95o2uzYI7" href="#p_d95o2uzYI7" tabindex="-1" role="presentation"></a>3つの正規表現を書いて順番にテストすることもできるけど、もっと良いやり方がある。パイプ( <code>|</code> )文字は、その左右にくるパターンのどちらかを選択するという意味を表す。以下のように使える。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_z0soEIN8RB" href="#c_z0soEIN8RB" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">animalCount</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b\d+ (pig|cow|chicken)s?\b/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;15 pigs&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;15 pigchickens&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p>カッコを使えばパイプ演算子が適用される範囲を制限できる。パイプを複数置けば、2つ以上の選択肢を表現できる。</p>

<h2><a class="h_ident" id="h_c8PkGE7nmH" href="#h_c8PkGE7nmH" tabindex="-1" role="presentation"></a>マッチングのメカニズム</h2>

<p><code>exec</code> や <code>test</code> を使うと正規表現エンジンは文字列からマッチする部分を探す。このとき、1文字目から2文字目と見ていき、マッチする部分が見つかるか文字列の終わりにたどり着くまで続ける。そうして見つかった最初のマッチする部分を返すか、失敗に終わるかどちらかだ。</p>

<p>実際のマッチングでは、正規表現エンジンは正規表現をフロー図のように扱っている。以下の図は前に見た家畜の数を表現するものだ。</p><figure><img src="img/re_pigchickens.svg" alt="Visualization of /\b\d+ (pig|cow|chicken)s?\b/"></figure>

<p>正規表現は図の左側から右側への道を見つけられればマッチすることになる。文字列の中での現在のポジションを保持していて、図の箱を通り抜けるたびに、現在のポジション以降の文字列がその箱にマッチするか確認していく。</p>

<p><a class="p_ident" id="p_G2RTiSRzpG" href="#p_G2RTiSRzpG" tabindex="-1" role="presentation"></a><code>&quot;the 3 pigs&quot;</code> をポジション4からマッチさせようとすれば、フロー図での進み方は以下のようになるだろう。</p>

<ul>

<li>

<p><a class="p_ident" id="p_Ltg3xZaKpU" href="#p_Ltg3xZaKpU" tabindex="-1" role="presentation"></a>ポジション4で、単語の境界がある。1番目の箱を通過できる。</p></li>

<li>

<p><a class="p_ident" id="p_FW7buSu4sm" href="#p_FW7buSu4sm" tabindex="-1" role="presentation"></a>まだポジション4のままで、十進数を見つける。2番目の箱も通過できる。</p></li>

<li>

<p><a class="p_ident" id="p_d7Qm5HcD+7" href="#p_d7Qm5HcD+7" tabindex="-1" role="presentation"></a>ポジション5で一方の道はループで2番目の(十進数の)箱の前に戻り、 もう一方はスペース文字1つの箱へ進む。ポジション5にはスペースがあって、 十進数ではないから、2つ目の道を進む。</p></li>

<li>

<p><a class="p_ident" id="p_z1EMlg+ogm" href="#p_z1EMlg+ogm" tabindex="-1" role="presentation"></a>ポジション6( <em>pigs</em> の始まり)に至って、図では3分岐に差し掛かる。 <em>cow</em> , <em>chicken</em> はないけど、 <em>pig</em> があるからその道を進む。</p></li>

<li>

<p><a class="p_ident" id="p_sEh+XmrT8x" href="#p_sEh+XmrT8x" tabindex="-1" role="presentation"></a>ポジション9で、つまり3分岐の後で、一方は <em>s</em> の箱をスキップして最後の境界へ 進む道、もう一方は <em>s</em> とマッチする道になっている。ここにs文字があるから (単語の境界ではなく)、 <em>s</em> の箱を通っていく。</p></li>

<li>

<p>ポジション10で(文字列の終端)まで来て、単語の境界しかマッチできない。 文字列の終端は単語の境界として扱われるから、最後の箱を通り抜けて、 文字列のマッチングは成功だ。</p></li></ul>

<h2 id="backtracking"><a class="h_ident" id="h_Y3TmW/Kkef" href="#h_Y3TmW/Kkef" tabindex="-1" role="presentation"></a>引き返し(Backtracking)</h2>

<p><a class="p_ident" id="p_VIOQs0a8sv" href="#p_VIOQs0a8sv" tabindex="-1" role="presentation"></a>正規表現 <code>/<wbr>\b([01]+b|[\da-f]+h|\d+)\b/<wbr></code> は、二進数の後に <em>b</em> がついたもの、十六進数の後に <em>h</em> がついたもの、普通の十進数のいずれかにマッチする。以下は、対応する図だ。</p><figure><img src="img/re_number.svg" alt="Visualization of /\b([01]+b|\d+|[\da-f]+h)\b/"></figure>

<p>上の正規表現をマッチングするときに、二進数の分岐にまず入るということがよく起こる。実際には入力の数字が二進数でなくても、例えば <code>&quot;103&quot;</code> は3が現れて初めて違った分岐だと分かる。この文字列は上の正規表現と <em>マッチする</em> けど、二進数の分岐が間違いだっただけだ。</p>

<p><a class="p_ident" id="p_jLPR/55tnK" href="#p_jLPR/55tnK" tabindex="-1" role="presentation"></a>つまり、マッチャーは <em>引き返す(backtrack)</em> 。ある分岐に入るときに、マッチャーはその時のポジションを覚えている(この場合には文字列の始まり、境界の箱を通過したところだ)。だから進んだ分岐の先でマッチしなければ、一旦戻って他の分岐を試すことができる。 <code>&quot;103&quot;</code> という文字列の場合には、3という文字に出くわした後に十六進数の分岐を試すけど、それも数字の後に <em>h</em> がないから失敗する。というわけで、十進数の分岐を進むことになって、マッチングの成功が報告される。</p>

<p>マッチャーはフルにマッチしたところで動作を終える。複数の分岐がマッチするかもしれない場合でも、(正規表現に現れる順番で)始めのものが使われるということだ。</p>

<p><a class="p_ident" id="p_CrZumjj7py" href="#p_CrZumjj7py" tabindex="-1" role="presentation"></a>引き返しは、 <code>+</code> や <code>*</code> のような繰返し演算子でも発生する <code>/^.*x/</code> というパターンを <code>&quot;abcxe&quot;</code> とマッチさせようとすると、 <code>*</code> はまず全ての文字列を食べ尽くそうとする。その後エンジンはパターンとマッチするには <em>x</em> が必要だと気づく。文字列の終了まで進んでしまえば、もう <em>x</em> はないから <code>*</code> 演算子はマッチする文字を1文字減らそうとする。でも、 <em>abcx</em> の後にも <em>x</em> はないからこれでもまだマッチしない。そこでもう1文字引き返して、 <code>*</code> 演算子が <em>abc</em> とマッチするようになれば、 <em>x</em> が必要な場所に見つかるようになって、ポジション0から4にかけてマッチが成功したと報告される。</p>

<p>引き返しが <em>多すぎる</em> 正規表現を書いてしまうこともあり得る。パターンがインプットにマッチする方法が多すぎるときにこの問題が起こる。例えば二進数にマッチする正規表現を書こうとして、間違って <code>/([01]+)+b/</code> と書いてしまうかもしれない。</p><figure><img src="img/re_slow.svg" alt="Visualization of /([01]+)+b/"></figure>

<p><a class="p_ident" id="p_9FrngKVTly" href="#p_9FrngKVTly" tabindex="-1" role="presentation"></a>このパターンを、0と1が長く続いて最後に <em>b</em> がない、という文字列とマッチさせようとすると、マッチャーはまず内側のループを進んで、数字を食べつくす。そこで <em>b</em> がないことに気づいて1文字引き返して、外側のループに入って、またギブアップする。それからまた内側のループに入る、というように全ての可能なルートを試そうとする。これは作業の量が1文字ごとに <em>倍になる</em> ということだ。数ダースの文字に対してマッチングにするのに、実質的に永遠の時間がかかるようになる。</p>

<h2><a class="h_ident" id="h_zFQI1ZDyWM" href="#h_zFQI1ZDyWM" tabindex="-1" role="presentation"></a>replaceメソッド</h2>

<p>文字列値には、 <code>replace</code> というメソッドがあって、文字列の一部を他の文字列で置き換えるために使う。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_dPdIdK/Wyi" href="#c_dPdIdK/Wyi" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;papa&quot;</span>.<span class="cm-property">replace</span>(<span class="cm-string">&quot;p&quot;</span>, <span class="cm-string">&quot;m&quot;</span>));
<span class="cm-comment">// → mapa</span></pre>

<p><code>replace</code> の1つ目の引数は正規表現でもよくて、その場合には最初にマッチした部分が置き換えられる。オプション <code>g</code> (グローバル)が正規表現に加えられていれば、最初だけではなくて文字列の <em>全ての</em> マッチした部分が置き換えられる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ztGnSKyKy1" href="#c_ztGnSKyKy1" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Borobudur&quot;</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/</span>, <span class="cm-string">&quot;a&quot;</span>));
<span class="cm-comment">// → Barobudur</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Borobudur&quot;</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/g</span>, <span class="cm-string">&quot;a&quot;</span>));
<span class="cm-comment">// → Barabadar</span></pre>

<p>全て置き換えるか最初のマッチだけ置き換えるかは、 <code>replace</code> メソッドに追加で引数を与えるとか、 <code>replaceAll</code> のようなメソッドを使うとかで選べた方が自然だ。だけど、残念なことに、正規表現のプロパティによって選択するしかない。</p>

<p>正規表現と <code>replace</code> メソッドを組み合わせる本当のパワーは、マッチしたグループを置き換え用の文字列で参照できることだ。例えば、1行ずつ人の名前を <code>Lastname</code> ,  <code>Firstname</code> のフォーマットで持った長い文字列があるとしよう。姓と名を入れ替えて、コンマを削除したいとしたら、次のコードが使える。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5P5aZAbVLL" href="#c_5P5aZAbVLL" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(
  <span class="cm-string">&quot;Liskov, Barbara\nMcCarthy, John\nWadler, Philip&quot;</span>
    .<span class="cm-property">replace</span>(<span class="cm-string-2">/(\w+), (\w+)/g</span>, <span class="cm-string">&quot;$2 $1&quot;</span>));
<span class="cm-comment">// → Barbara Liskov</span>
<span class="cm-comment">//   John McCarthy</span>
<span class="cm-comment">//   Philip Wadler</span></pre>

<p>ここで、置き換え用の文字列の <code>$1</code> と <code>$2</code> は、パターンの中のカッコで囲まれたグループを指している。 <code>$1</code> は最初のグループにマッチしたテキストと置き換えられ、 <code>$2</code> は二番目のグループと、というように続き <code>$9</code> まで使える。マッチ全体は <code>$&amp;</code> で参照できる。</p>

<p><code>replace</code> の2番目の引数には、文字列ではなくて関数を渡すこともできる。置き換えるごとに、その関数がマッチしたグループを引数にして呼び出される。そして返り値が新しい文字列に挿入される。</p>

<p>これはちょっとした例だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fwgl3+oeyX" href="#c_fwgl3+oeyX" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">s</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;the cia and fbi&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">s</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\b(fbi|cia)\b/g</span>,
            <span class="cm-def">str</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">str</span>.<span class="cm-property">toUpperCase</span>()));
<span class="cm-comment">// → the CIA and FBI</span></pre>

<p>これはさらに面白い例だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Zo/y2Vv93l" href="#c_Zo/y2Vv93l" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">stock</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;1 lemon, 2 cabbages, and 101 eggs&quot;</span>;
<span class="cm-keyword">function</span> <span class="cm-def">minusOne</span>(<span class="cm-def">match</span>, <span class="cm-def">amount</span>, <span class="cm-def">unit</span>) {
  <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable-2">amount</span>) <span class="cm-operator">-</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) { <span class="cm-comment">// only one left, remove the 's'</span>
    <span class="cm-variable-2">unit</span> <span class="cm-operator">=</span> <span class="cm-variable-2">unit</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">unit</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;no&quot;</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">+</span> <span class="cm-string">&quot; &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">unit</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stock</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/(\d+) (\w+)/g</span>, <span class="cm-variable">minusOne</span>));
<span class="cm-comment">// → no lemon, 1 cabbage, and 100 eggs</span></pre>

<p>この関数は文字列を引数に取って、数字に英数字が続くパターンを探して、その数字から1引いた値を挿入して文字列を返す。</p>

<p><a class="p_ident" id="p_U9mavMZxuB" href="#p_U9mavMZxuB" tabindex="-1" role="presentation"></a>関数の中では、 <code>(\d+)</code> のグループが <code>amount</code> に、 <code>(\w+)</code> が <code>unit</code> にバインドされる。関数の中では <code>amount</code> は数字に変換されるけど、 <code>\d+</code> にマッチしたのだからこの変換は常に成功する。そして <code>amount</code> が1か0の場合には少し修正を加える。</p>

<h2><a class="h_ident" id="h_8ratxQ3o8H" href="#h_8ratxQ3o8H" tabindex="-1" role="presentation"></a>貪欲(Greed)</h2>

<p><code>replace</code> を使ってJavaScriptのコードからコメントを削除する関数を書くことができる。以下が最初の試みだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_u0oKSJTOA2" href="#c_u0oKSJTOA2" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*\*\//g</span>, <span class="cm-string">&quot;&quot;</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;1 + /* 2 */3&quot;</span>));
<span class="cm-comment">// → 1 + 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;x = 10;// ten!&quot;</span>));
<span class="cm-comment">// → x = 10;</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;1 /* a */+/* b */ 1&quot;</span>));
<span class="cm-comment">// → 1  1</span></pre>

<p><a class="p_ident" id="p_ov8tYGKzyK" href="#p_ov8tYGKzyK" tabindex="-1" role="presentation"></a><em>or</em> 演算子(<code>|</code>) の前の部分は、スラッシュ文字2つに改行文字以外が続いたパターンとマッチする。複数行のコメントとマッチする部分はもっと複雑だ。ここで <code>[^]</code> は、何もない文字以外という意味になるので、全ての文字にマッチする。コメントは行をまたいで続くかも知れなくて、ピリオドは改行にはマッチしないからだ。</p>

<p>でも、最後の文字列への結果はおかしくなってしまった。なぜだろう?</p>

<p><a class="p_ident" id="p_TUjUGk8Fbx" href="#p_TUjUGk8Fbx" tabindex="-1" role="presentation"></a>正規表現の <code>[^]*</code> の部分は、引き返しのセクションで説明したように、まずはできるだけ多くマッチしようとする。もし、それ以降のパターンがマッチしなくなるなら、マッチャーは1文字引き返してリトライするはずだ。この例では、 <code>[^]*</code> の部分は、まずは文字列を最後までマッチしようとして、そこから引き返していく。文字列の最後から4文字引き返したところで、 <code>*/</code> が発見されるからマッチする。これは意図したこととは違う。1つずつのコメントにマッチさせるつもりが、文字列の最後まで見て、1つ目の始まりと2つ目の終わりがマッチしてしまった。</p>

<p><a class="p_ident" id="p_B5O3ddT6qG" href="#p_B5O3ddT6qG" tabindex="-1" role="presentation"></a>このふるまいから、繰返し演算子( <code>+</code> , <code>*</code> , <code>?</code> , <code>{}</code> )を <em>貪欲(greedy)</em> と表現する。まずできるだけたくさんマッチしてから引き返すからだ。これらの後ろにクエスチョンマークを置けば( <code>+?</code> , <code>*?</code> , <code>??</code> , <code>{}?</code> )、貪欲ではなくなって、できるだけ少なくマッチするようになる。残りのパターンが上手くマッチしないときだけさらに多くマッチするようになるんだ。</p>

<p>そして、これがまさにこの例で必要なものだ。 <code>[^]*</code> のマッチを <code>[^]*?</code> にして最小限だけマッチするように変えれば、ブロックコメント1つ分だけマッチして、それ以上に広がることはない。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_MCNF7GxfR1" href="#c_MCNF7GxfR1" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*?\*\//g</span>, <span class="cm-string">&quot;&quot;</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;1 /* a */+/* b */ 1&quot;</span>));
<span class="cm-comment">// → 1 + 1</span></pre>

<p>正規表現プログラムのバグの多くは、非貪欲にした方が上手くいくところで、貪欲な演算子を使ってしまっていることが原因だ。繰返しの演算子を使うときには、まずは非貪欲なバージョンを使うことを考えよう。</p>

<h2><a class="h_ident" id="h_tZqcyUmbsI" href="#h_tZqcyUmbsI" tabindex="-1" role="presentation"></a>RegExpオブジェクトの動的な生成</h2>

<p>コードを書いている時点では、マッチさせるべきパターンが分からないという場合もある。ちょっとしたテキストからユーザの名前を探して、アンダースコアを挟んで目立つようにしたいとしよう。プログラムが実行されるまではユーザの名前は分からないから、スラッシュを使った記法は使えない。</p>

<p>この場合は文字列を組み立ててから、 <code>RegExp</code> コンストラクターに渡せばいい。以下はその例だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_3yQimfD35d" href="#c_3yQimfD35d" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">name</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;harry&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Harry is a suspicious character.&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">&quot;\\b(&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable">name</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;)\\b&quot;</span>, <span class="cm-string">&quot;gi&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">&quot;_$1_&quot;</span>));
<span class="cm-comment">// → _Harry_ is a suspicious character.</span></pre>

<p><code>\b</code> で境界マーカーを作るときは、普通の文字列の中に書いているから、バックスラッシュをもう1つ足してエスケープしないといけない。 <code>RegExp</code> の2つ目の引数は正規表現のオプションだ。この場合の <code>&quot;gi&quot;</code> はグローバルで、大文字小文字を区別しないという意味だ。</p>

<p>ユーザが中二病で、名前が <code>&quot;dea+hl[]rd&quot;</code> だったらどうすればいい?これではめちゃくちゃな正規表現が出来上がってしまって、ユーザ名とマッチしないだろう。</p>

<p>これをなんとかするためには、特別な意味を持つ文字全てをバックスラッシュでエスケープすればいい。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VVThPW6YGV" href="#c_VVThPW6YGV" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">name</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;dea+hl[]rd&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;This dea+hl[]rd guy is super annoying.&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">escaped</span> <span class="cm-operator">=</span> <span class="cm-variable">name</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[\\[.+*?(){|^$]/g</span>, <span class="cm-string">&quot;\\$&amp;&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">&quot;\\b&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable">escaped</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;\\b&quot;</span>, <span class="cm-string">&quot;gi&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">&quot;_$&amp;_&quot;</span>));
<span class="cm-comment">// → This _dea+hl[]rd_ guy is super annoying.</span></pre>

<h2><a class="h_ident" id="h_G+nHsSMf6f" href="#h_G+nHsSMf6f" tabindex="-1" role="presentation"></a>searchメソッド</h2>

<p>文字列の <code>indexOf</code> メソッドは、正規表現を引数にして呼ぶことはできない。でも、 <code>search</code> というもう1つのメソッドがある。これは正規表現を引数に取って、 <code>indexOf</code> と同じように、そのパターンが最初に見つかったインデックスを返す。見つからなかった場合には-1が返される。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_diUfxE6ifs" href="#c_diUfxE6ifs" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;  word&quot;</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;    &quot;</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → -1</span></pre>

<p>残念ながら、マッチを始めるポジションを指定することはできない( <code>indexOf</code> に2番目の引数を与えるように)。できれば便利だっただろうけど。</p>

<h2><a class="h_ident" id="h_Uz0BBxwxHY" href="#h_Uz0BBxwxHY" tabindex="-1" role="presentation"></a>lastIndexプロパティ</h2>

<p><code>exec</code> メソッドも同じように、文字列の探索開始場所を指定する便利な方法がない。だけど、不便な方法だったら、ある。</p>

<p>正規表現オブジェクトにはいくつかのプロパティがある。たとえば <code>source</code> プロパティは正規表現が生成された元の文字列を保持している。そして <code>lastIndex</code> プロパティは、特定の状況でだけ、次のマッチが開始するポジションをコントロールする。</p>

<p><a class="p_ident" id="p_0hDNfTtQRd" href="#p_0hDNfTtQRd" tabindex="-1" role="presentation"></a>その状況というのは、正規表現のグローバル( <code>g</code> )かスティッキー( <code>y</code> )のオプションが有効になっていて、マッチングが <code>exec</code> メソッドで行われているということだ。ここでも、もっと分かりやすいやり方は <code>exec</code> メソッッドにもう1つ引数を渡せるようにすることだろうけど、分かりにくさはJavaScriptの正規表現インターフェイスの欠かせない機能のようなものなんだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_nXsHtqIJdF" href="#c_nXsHtqIJdF" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">pattern</span> <span class="cm-operator">=</span> <span class="cm-string-2">/y/g</span>;
<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
<span class="cm-keyword">let</span> <span class="cm-def">match</span> <span class="cm-operator">=</span> <span class="cm-variable">pattern</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;xyzzy&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span>);
<span class="cm-comment">// → 5</span></pre>

<p><a class="p_ident" id="p_cXpMwVrt3i" href="#p_cXpMwVrt3i" tabindex="-1" role="presentation"></a>マッチが成功すると、 <code>exec</code> メソッドは自動的に <code>lastIndex</code> をマッチした位置の次にアップデートする。失敗した場合には <code>lastIndex</code> は0に戻される。新しく作られた正規表現オブジェクトにも初期値として0が与えられる。</p>

<p>グローバルとスティッキーの違いは、スティッキーが有効の場合には、マッチが <code>lastIndex</code> から始まっている場合にだけ成功になるということだ。一方で、グローバルの場合にはマッチャーは前の方を探しに行って、マッチが開始できるポジションを探す。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_98GwGRIMj8" href="#c_98GwGRIMj8" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">global</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/g</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">global</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;xyz abc&quot;</span>));
<span class="cm-comment">// → [&quot;abc&quot;]</span>
<span class="cm-keyword">let</span> <span class="cm-def">sticky</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/y</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sticky</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;xyz abc&quot;</span>));
<span class="cm-comment">// → null</span></pre>

<p>同じ正規表現オブジェクトを複数の <code>exec</code> で共有する場合には、 <code>lastIndex</code> の自動アップデートが問題を起こすかもしれない。マッチングが、 <code>exec</code> が前の呼び出しで覚えた位置から始まってしまうかもしれないからだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_wrx2wO0P8M" href="#c_wrx2wO0P8M" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">digit</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d/g</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;here it is: 1&quot;</span>));
<span class="cm-comment">// → [&quot;1&quot;]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;and now: 1&quot;</span>));
<span class="cm-comment">// → null</span></pre>

<p>他にも面白いのは、グローバルオプションが文字列の <code>match</code> メソッドのふるまいも変えてしまうことだ。 <code>match</code> は、 <code>exec</code> によって返される配列のようなものとは違って、文字列からパターンのマッチを <em>全て</em> 探して、それらを含む配列を返すようになるんだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_weT/d5+8vE" href="#c_weT/d5+8vE" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Banana&quot;</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/an/g</span>));
<span class="cm-comment">// → [&quot;an&quot;, &quot;an&quot;]</span></pre>

<p>というわけで正規表現のグローバルオプションには注意しよう。そして必要なときだけ使うようにしよう。 <code>replace</code> メソッドを呼び出すときや、 <code>lastIndex</code> を明示的に使いたいときが典型的な使い道だろう。</p>

<h3><a class="i_ident" id="i_QRYRKZKylj" href="#i_QRYRKZKylj" tabindex="-1" role="presentation"></a>マッチのループ</h3>

<p>文字列中からパターンの出現全てをスキャンしていって、ループ内でマッチオブジェクトにアクセスしたい、ということがよくある。 <code>lastIndex</code> と <code>exec</code> を使えばこれを実現できる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_rSzEnbVHja" href="#c_rSzEnbVHja" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;A string with 3 numbers in it... 42 and 88.&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b\d+\b/g</span>;
<span class="cm-keyword">let</span> <span class="cm-def">match</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">number</span>.<span class="cm-property">exec</span>(<span class="cm-variable">input</span>)) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Found&quot;</span>, <span class="cm-variable">match</span>[<span class="cm-number">0</span>], <span class="cm-string">&quot;at&quot;</span>, <span class="cm-variable">match</span>.<span class="cm-property">index</span>);
}
<span class="cm-comment">// → Found 3 at 14</span>
<span class="cm-comment">//   Found 42 at 33</span>
<span class="cm-comment">//   Found 88 at 40</span></pre>

<p>ここでは、代入式( <code>=</code> )の値自体も、代入される値になることを利用している。 <code>while</code> 宣言の条件として <code>match = number.<wbr>exec(input)</code> を使うと、各イテレーションの最初にマッチングを行って、結果を <code>match</code> バインディングに保存して、マッチしなくなればループを終了することになる。</p>

<h2 id="ini"><a class="h_ident" id="h_8o3BpubpJl" href="#h_8o3BpubpJl" tabindex="-1" role="presentation"></a>INIファイルのパース</h2>

<p>この章を終える前に、正規表現が必要になる問題を見てみよう。インターネットから敵の情報を自動で収集するプログラムを書くことを想像しよう。(ここでは実際にそのプログラムは書かない。設定ファイルを読み込む部分だけだ。申し訳ない。)設定ファイルはこういう見た目になるだろう。</p>

<pre class="snippet cm-s-default" data-language="text/plain" ><a class="c_ident" id="c_/2jyS6L+W5" href="#c_/2jyS6L+W5" tabindex="-1" role="presentation"></a>searchengine=https://duckduckgo.com/?q=$1
spitefulness=9.7
;訳注 spitefulness: 悪意・敵意の度合い

; comments are preceded by a semicolon...(コメントはセミコロンの後に続ける)
; each section concerns an individual enemy(各セクションが個々の敵を扱う)
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451
;訳注 kindergarten bully: 幼稚園のいじめっ子

[davaeorn]
fullname=Davaeorn
type=evil wizard
outputdir=/home/marijn/enemies/davaeorn
;訳注 evil wizard: 悪の魔法使い</pre>

<p><a class="p_ident" id="p_5+sfP6l0gN" href="#p_5+sfP6l0gN" tabindex="-1" role="presentation"></a>このフォーマットのルールは以下のように整理できる。これは広く使われているフォーマットで、 <em>INI</em> ファイルと呼ばれる。</p>

<ul>

<li>

<p>空の行と、セミコロンで始まる行は無視される。</p></li>

<li>

<p><code>[</code> と <code>]</code> で囲まれた行は、新しいセクションの始まりになる。</p></li>

<li>

<p>英数字の名前(識別子)の後に <code>=</code> が続く行は、現在のセクションに設定を追加する。</p></li>

<li>

<p>それ以外のものは無効になる。</p></li></ul>

<p>ぼくらのタスクは上のような文字列を1つのオブジェクトにまとめることだ。このオブジェクトが、始めのセクションより前に書かれた設定と各セクションを表すサブオブジェクトをプロパティとして持つようにする。セクションごとのサブオブジェクトには、そのセクションの設定を保持させる。</p>

<p><a class="p_ident" id="p_5AqqPPoTNi" href="#p_5AqqPPoTNi" tabindex="-1" role="presentation"></a>INIフォーマットは行ごとに処理しないといけないから、まずはファイルの内容を行ごとに分けてしまうと取りかかりやすい。<a href="04_data.html#split">4</a>章では <code>split</code> メソッドについて見た。OSによっては、行を分けるために改行文字だけではなく、キャリッジリターン文字と改行文字を合わせて使っている場合がある( <code>&quot;\r\n&quot;</code> のように)。 <code>split</code> メソッドは正規表現も引数に受け取ることもできるから、 <code>/\r?\n/</code> を渡せば <code>&quot;\n&quot;</code> と <code>&quot;\r\n&quot;</code> のどちらの改行にも対応できる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_neI86/XXg2" href="#c_neI86/XXg2" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">parseINI</span>(<span class="cm-def">string</span>) {
  <span class="cm-comment">// Start with an object to hold the top-level fields</span>
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> {};
  <span class="cm-keyword">let</span> <span class="cm-def">section</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>;
  <span class="cm-variable-2">string</span>.<span class="cm-property">split</span>(<span class="cm-string-2">/\r?\n/</span>).<span class="cm-property">forEach</span>(<span class="cm-def">line</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">match</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^(\w+)=(.*)$/</span>)) {
      <span class="cm-variable-2">section</span>[<span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]] <span class="cm-operator">=</span> <span class="cm-variable-2">match</span>[<span class="cm-number">2</span>];
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^\[(.*)\]$/</span>)) {
      <span class="cm-variable-2">section</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>[<span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]] <span class="cm-operator">=</span> {};
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-string-2">/^\s*(;.*)?$/</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">line</span>)) {
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Line '&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">line</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;' is not valid.&quot;</span>);
    }
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parseINI</span>(<span class="cm-string-2">`</span>
<span class="cm-string-2">name=Vasilis</span>
<span class="cm-string-2">[address]</span>
<span class="cm-string-2">city=Tessaloniki`</span>));
<span class="cm-comment">// → {name: &quot;Vasilis&quot;, address: {city: &quot;Tessaloniki&quot;}}</span></pre>

<p>このコードはファイルを行ごとに見ていって、1つのオブジェクトを組み立てる。ファイルの頭で見つかったプロパティはオブジェクトに直接保持されて、セクション内のプロパティはセクション毎のオブジェクトに保持される。 <code>section</code> バインディングは、そのとき扱っている行のセクションを示している。</p>

<p>セクションヘッダーの行とプロパティの行という特徴的な2種類の行がある。ある行が普通のプロパティであれば、現在のセクションに保持される。セクションヘッダーの行であれば、新しいセクションのためにオブジェクトが作られて、 <code>section</code> バインディングはそのオブジェクトを指すようになる。</p>

<p><code>^</code> と <code>$</code> を毎回書いて、確実に行全体がマッチするようにしていることに注意してほしい。これをなくしてしまうと、たいていの場合には上手くいくのにたまに失敗するコードになってしまう。これは追跡が難しいバグだ。</p>

<p><code>if (match = string.<wbr>match(.<wbr>.<wbr>.<wbr>))</code> のパターンは <code>while</code> の条件部分で代入を使うワザと同じだ。 <code>match</code> の呼び出しは成功するかどうか分からないことが多いから、それをテストする <code>if</code> 文の中でだけ結果の <code>match</code> オブジェクトにアクセスする。 <code>else if</code> 形式の分かりやすいチェインを壊したくないから、マッチの結果をバインディングに代入して、その代入が生む値を <code>if</code> 文のテストで使っているんだ。</p>

<p>ある行がセクションヘッダーとプロパティのどちらでもなければ、 <code>/^\s*(;.*)?$/</code> という正規表現でコメント行なのか空行なのかチェックされる。どういう仕組みか分かるだろうか?カッコの間の部分はコメントにマッチする。そこに <code>?</code> が続くからホワイトスペースだけの行にもマッチするようになっている。期待される形式のどれにもマッチしない行があれば、 <code>parseINI</code>関数は例外を発生させる。</p>

<h2><a class="h_ident" id="h_GDxe7QvqDv" href="#h_GDxe7QvqDv" tabindex="-1" role="presentation"></a>国際文字</h2>

<p><a class="p_ident" id="p_JtpQsLoXY0" href="#p_JtpQsLoXY0" tabindex="-1" role="presentation"></a>JavaScriptの初期の実装が単純なものだった上に、この単純なアプローチがもはや動かせないものになってしまったから、JavaScriptの正規表現は英語で使われる文字以外に関してはアホとしかいいようがない。例えば、&quot;言葉の文字&quot;( <code>\w</code> )として扱われるのはラテンアルファベットの26文字(の大文字と小文字)と十進数の数字とアンダースコアだけだ。 <em>é</em> や <em>β</em> はどう考えても言葉の文字だけど、 <code>\w</code> にはマッチしないで、 <code>\W</code> (言葉以外)にマッチする。</p>

<p><a class="p_ident" id="p_mrC9mmEm7k" href="#p_mrC9mmEm7k" tabindex="-1" role="presentation"></a>歴史的な偶然で <code>\s</code> (ホワイトスペース)にはこの問題がなくて、Unicode標準がホワイトスペースと見なす文字全てにマッチする。ノーブレークスペースやモンゴル語の母音を分ける文字でも問題ないんだ。</p>

<p><a class="p_ident" id="p_UNX7DvbvMg" href="#p_UNX7DvbvMg" tabindex="-1" role="presentation"></a>もう1つの問題は、デフォルトの正規表現は(<a href="05_higher_order.html#code_units">5</a>章で見てきた)コードユニット毎に作用するということだ(実際の文字ごとではなく)。だから、2つのコードユニットを使う文字ではおかしな挙動になるんだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CfMTYxun8D" href="#c_CfMTYxun8D" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/🍎{3}/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;🍎🍎🍎&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/&lt;.&gt;/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;&lt;🌹&gt;&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/&lt;.&gt;/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;&lt;🌹&gt;&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_MdO1n/nUjP" href="#p_MdO1n/nUjP" tabindex="-1" role="presentation"></a>問題は、最初の行での🍎は2コードユニットとして扱われるから <code>{3}</code> の部分が2つ目の🍎までしかマッチできないことだ。同じように、ドットは1コードユニットにしかマッチできないから、バラの絵文字の2コードユニットには失敗してしまうんだ。</p>

<p>こういう文字を上手く扱うには正規表現に <code>u</code> オプション(Unicodeという意味)を付けるしかない。デフォルトの動作はおかしいままだけど、それを変えてしまうと既存のコードがおかしくなってしまうかもしれないんだ。</p>

<p>この本を書いている時点では、標準化されたばかりで広くサポートされているわけではないけど、正規表現で <code>\p</code> を使えば、そのプロパティにUnicode標準が割り当てる文字全てにマッチさせることもできる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_+jV1oln0sr" href="#c_+jV1oln0sr" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Script=Greek}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;α&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Script=Arabic}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;α&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Alphabetic}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;α&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Alphabetic}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;!&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_jZHfu9dFbz" href="#p_jZHfu9dFbz" tabindex="-1" role="presentation"></a>Unicodeには便利なプロパティがたくさん用意されているけど、その中から必要なものを探してくるのは大変かもしれない。 <code>\p{Property=Value}</code> と書けば、そのプロパティのValueを持っている文字全てにマッチできる。プロパティ名を省略して <code>\p{Name}</code> とすると、 <code>Alphabetic</code> のようなバイナリープロパティの値か、 <code>Number</code> のようなカテゴリー名として扱われる。</p>

<h2 id="summary_regexp"><a class="h_ident" id="h_WvYIPtb9vj" href="#h_WvYIPtb9vj" tabindex="-1" role="presentation"></a>まとめ</h2>

<p>正規表現は文字列のパターンを表現するオブジェクトだ。以下のように、オリジナルの言語でパターンを表現する。</p>

<table>

<tr><td><code>/abc/</code></td><td>文字のシーケンス</td>

</tr>

<tr><td><code>/[abc]/</code></td><td>文字セットのうちのどれか</td>

</tr>

<tr><td><code>/[^abc]/</code></td><td>文字セットに <em>含まれない</em> 全ての文字</td>

</tr>

<tr><td><code>/[0-9]/</code></td><td>文字範囲に含まれる全ての文字</td>

</tr>

<tr><td><code>/x+/</code></td><td>パターン <code>x</code> が1回以上出現</td>

</tr>

<tr><td><code>/x+?/</code></td><td>1回以上出現、貪欲ではない</td>

</tr>

<tr><td><code>/x*/</code></td><td>0回以上出現</td>

</tr>

<tr><td><code>/x?/</code></td><td>0回以上出現</td>

</tr>

<tr><td><code>/x{2,4}/</code></td><td>2から4回出現</td>

</tr>

<tr><td><code>/(abc)/</code></td><td>グループ</td>

</tr>

<tr><td><code>/a|b|c/</code></td><td>複数のパターンのどれか</td>

</tr>

<tr><td><code>/\d/</code></td><td>全ての十進数文字</td>

</tr>

<tr><td><code>/\w/</code></td><td>英数字 (&quot;言葉の文字&quot;)</td>

</tr>

<tr><td><code>/\s/</code></td><td>ホワイトスペース</td>

</tr>

<tr><td><code>/./</code></td><td>改行以外の全ての文字</td>

</tr>

<tr><td><code>/\b/</code></td><td>単語の境界</td>

</tr>

<tr><td><code>/^/</code></td><td>入力の始まり</td>

</tr>

<tr><td><code>/$/</code></td><td>入力の終わり</td>

</tr>

</table>

<p>正規表現には <code>test</code> というメソッドがあって、与えられた文字列がマッチするかどうかテストする。また、 <code>exec</code> メソッドは、マッチしたときには、マッチしたグループを全て含んだ配列を返す。この配列には <code>index</code> プロパティがあって、マッチの開始位置を示す。</p>

<p>文字列には <code>match</code> というメソッドがあって、引数の正規表現とマッチするか調べる。 <code>search</code> メソッドはマッチ開始位置だけを返す。 <code>replace</code> メソッドは、マッチしたパターンを文字列か関数で置き換える。</p>

<p><a class="p_ident" id="p_9YpnO4d0XH" href="#p_9YpnO4d0XH" tabindex="-1" role="presentation"></a>正規表現には閉じるスラッシュの後にオプションを付けられる。 <code>i</code> オプションはマッチングが大文字小文字を区別しないようにする。 <code>g</code> オプションは正規表現を <em>グローバル</em> に変えて、特に <code>replace</code> メソッドを始めのマッチだけではなく全てのマッチを置き換えるようにする。 <code>y</code> オプションはマッチをスティッキーにする。つまり、マッチを探すときに文字列をスキップして前に進めないようにするんだ。 <code>u</code> オプションはUnicodeモードをオンにする。これは2コードユニットの文字に関する問題を解決してくれるんだ。</p>

<p>正規表現は、切れ味鋭いツールに不格好な持ち手が付いたようなものだ。タスクをものすごくシンプルにすることもあれば、複雑な問題に使おうとしてすぐに制御不能になることもある。正規表現の使い方を知るということは、正規表現では上手く表現できない問題にも無理やり当てはめたくなる衝動に逆らうことでもあるんだ。</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>Exercises</h2>

<p><a class="p_ident" id="p_ZLZe6zjlTr" href="#p_ZLZe6zjlTr" tabindex="-1" role="presentation"></a>このエクササイズに取り組んでいる間、正規表現の不可解なふるまいに混乱したりイラついたりするのは、まず避けられないだろう。<a href="https://www.debuggex.com/"><em>https://debuggex.com</em></a>のようなオンラインツールに入力して、可視化されたものが意図に合っているか見たり、文字の入力にどう反応するか実験してみたりするといい。</p>

<h3><a class="i_ident" id="i_vDM8PzwQWU" href="#i_vDM8PzwQWU" tabindex="-1" role="presentation"></a>Regexp golf</h3>

<p>(正規表現ゴルフ)</p>

<p><em>コードゴルフ</em> は、あるプログラムを可能な限り短く表現するゲームだ。同じように、 <em>正規表現ゴルフ</em> はできるだけ小さい正規表現で与えられたパターン( <em>だけ</em> )にマッチさせる、というものだ。</p>

<p>次のアイテムそれぞれに、部分文字列が文字列の中にあるかどうかテストする正規表現を書こう。この正規表現は部分文字列を含んでいるものだけにマッチするようにしないといけない。単語の境界については明示的に指定しない限り気にしなくていい。きちんと動作するようになったら、さらに短くできるか考えてみよう。</p>

<ol>

<li>

<p><a class="p_ident" id="p_xvWnbeToqT" href="#p_xvWnbeToqT" tabindex="-1" role="presentation"></a><em>car</em> と <em>cat</em></p></li>

<li>

<p><a class="p_ident" id="p_GyRYO2ZOIs" href="#p_GyRYO2ZOIs" tabindex="-1" role="presentation"></a><em>pop</em> と <em>prop</em></p></li>

<li>

<p><a class="p_ident" id="p_NCSfDeF7SR" href="#p_NCSfDeF7SR" tabindex="-1" role="presentation"></a><em>ferret</em>, <em>ferry</em>, そして <em>ferrari</em></p></li>

<li>

<p><a class="p_ident" id="p_mTg3ONUIhL" href="#p_mTg3ONUIhL" tabindex="-1" role="presentation"></a><em>ious</em> で終わる全ての単語</p></li>

<li>

<p>ホワイトスペースにピリオド、コンマ、もしくはセミコロンが続いたもの</p></li>

<li>

<p><a class="p_ident" id="p_wd/ZbuqMwr" href="#p_wd/ZbuqMwr" tabindex="-1" role="presentation"></a>6文字より長い単語</p></li>

<li>

<p><a class="p_ident" id="p_LnjCe/FXPh" href="#p_LnjCe/FXPh" tabindex="-1" role="presentation"></a><em>e</em> (もしくは <em>E</em>)の文字が入っていない単語</p></li>

</ol>

<p><a href="09_regexp.html#summary_regexp">章のまとめ</a>の表をヘルプとして参照しよう。それぞれの回答をいくつかのテスト文字列で試してみよう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_GKjX1B6/kX" href="#c_GKjX1B6/kX" tabindex="-1" role="presentation"></a><span class="cm-comment">// 正規表現を埋めよう</span>

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;my car&quot;</span>, <span class="cm-string">&quot;bad cats&quot;</span>],
       [<span class="cm-string">&quot;camper&quot;</span>, <span class="cm-string">&quot;high art&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;pop culture&quot;</span>, <span class="cm-string">&quot;mad props&quot;</span>],
       [<span class="cm-string">&quot;plop&quot;</span>, <span class="cm-string">&quot;prrrop&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;ferret&quot;</span>, <span class="cm-string">&quot;ferry&quot;</span>, <span class="cm-string">&quot;ferrari&quot;</span>],
       [<span class="cm-string">&quot;ferrum&quot;</span>, <span class="cm-string">&quot;transfer A&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;how delicious&quot;</span>, <span class="cm-string">&quot;spacious room&quot;</span>],
       [<span class="cm-string">&quot;ruinous&quot;</span>, <span class="cm-string">&quot;consciousness&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;bad punctuation .&quot;</span>],
       [<span class="cm-string">&quot;escape the period&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;hottentottententen&quot;</span>],
       [<span class="cm-string">&quot;no&quot;</span>, <span class="cm-string">&quot;hotten totten tenten&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;red platypus&quot;</span>, <span class="cm-string">&quot;wobbling nest&quot;</span>],
       [<span class="cm-string">&quot;earth bed&quot;</span>, <span class="cm-string">&quot;learning ape&quot;</span>, <span class="cm-string">&quot;BEET&quot;</span>]);


<span class="cm-keyword">function</span> <span class="cm-def">verify</span>(<span class="cm-def">regexp</span>, <span class="cm-def">yes</span>, <span class="cm-def">no</span>) {
  <span class="cm-comment">// Ignore unfinished exercises</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">source</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;...&quot;</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">yes</span>) <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failure to match '${</span><span class="cm-variable-2">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">no</span>) <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Unexpected match for '${</span><span class="cm-variable-2">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
}</pre>

<h3><a class="i_ident" id="i_dTiEW14oG0" href="#i_dTiEW14oG0" tabindex="-1" role="presentation"></a>Quoting style</h3>

<p>(クオートのスタイル)</p>

<p><a class="p_ident" id="p_sHr9S/fcCS" href="#p_sHr9S/fcCS" tabindex="-1" role="presentation"></a>物語を書いていて、その中ではシングルクオーテーションを会話文を表すために使っているとしよう。でも、全ての会話文のクオートをダブルクオートに替えたくなった。 <em>aren’t</em> のような短縮形で使われるシングルクオートはそのままにしつつ、だ。</p>

<p>この2種類のクオートの用途を区別するパターンを考えてみよう。そして、この置き換えを実行する <code>replace</code> メソッドの呼び出しをしてみよう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_sPrcOR+s/4" href="#c_sPrcOR+s/4" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;'I'm the cook,' he said, 'it's my job.'&quot;</span>;
<span class="cm-comment">// Change this call.</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/A/g</span>, <span class="cm-string">&quot;B&quot;</span>));
<span class="cm-comment">// → &quot;I'm the cook,&quot; he said, &quot;it's my job.&quot;</span></pre>

<div class="solution"><div class="solution-text">

<p>一番簡単な回答は少なくとも片側に言葉以外の文字があるクオートを置き換えることだ。例えば、 <code>/\W'|'\W/</code> のようにして。でも、行の始めと終わりも考慮しないといけない。</p>

<p>さらに、置き換えの文字列が <code>\W</code> パターンでマッチした文字列を含むようにしないといけない。これは、そのパターンをカッコで囲んでおいて、置き換え文字列にそのグループ(<code>$1</code>, <code>$2</code>)を入れればいい。マッチしなかったグループは、無と置き換えられる(置き換えられない)。</p>

</div></div>

<h3><a class="i_ident" id="i_izldJoT3uv" href="#i_izldJoT3uv" tabindex="-1" role="presentation"></a>Numbers again</h3>

<p>(数値再び)</p>

<p><a class="p_ident" id="p_78aDwuALBZ" href="#p_78aDwuALBZ" tabindex="-1" role="presentation"></a>JavaScriptスタイルの数値だけにマッチする正規表現を書こう。オプションで数字の前のマイナス記号 <em>もしくは</em> プラス記号を受けつけるようにする。それから十進数のドットもだ。さらに、 <code>5e-3</code> や <code>1E10</code> のような指数の表記も受け付ける(ここでも指数の前に符号を付けられるようにする)。それから小数点のドットの前や後ろに数字がなくても問題ない(とはいえ、ドットだけではいけない)。つまり、 <code>.5</code> や <code>5.</code> は有効なJavaScriptの数字で、ドットだけは <em>有効ではない</em> 。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_aHAzeMYYGe" href="#c_aHAzeMYYGe" tabindex="-1" role="presentation"></a><span class="cm-comment">// Fill in this regular expression.</span>
<span class="cm-keyword">let</span> <span class="cm-def">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^...$/</span>;

<span class="cm-comment">// Tests:</span>
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> [<span class="cm-string">&quot;1&quot;</span>, <span class="cm-string">&quot;-1&quot;</span>, <span class="cm-string">&quot;+15&quot;</span>, <span class="cm-string">&quot;1.55&quot;</span>, <span class="cm-string">&quot;.5&quot;</span>, <span class="cm-string">&quot;5.&quot;</span>,
                 <span class="cm-string">&quot;1.3e2&quot;</span>, <span class="cm-string">&quot;1E-4&quot;</span>, <span class="cm-string">&quot;1e+12&quot;</span>]) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failed to match '${</span><span class="cm-variable">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
}
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> [<span class="cm-string">&quot;1a&quot;</span>, <span class="cm-string">&quot;+-1&quot;</span>, <span class="cm-string">&quot;1.2.3&quot;</span>, <span class="cm-string">&quot;1+1&quot;</span>, <span class="cm-string">&quot;1e4.5&quot;</span>,
                 <span class="cm-string">&quot;.5.&quot;</span>, <span class="cm-string">&quot;1f5&quot;</span>, <span class="cm-string">&quot;.&quot;</span>]) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Incorrectly accepted '${</span><span class="cm-variable">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
}</pre>

<div class="solution"><div class="solution-text">

<p>まずは、ピリオドの前にバックスラッシュを付けるのを忘れないように。</p>

<p>数字や指数の前に付けるオプションの符号にマッチさせるには、 <code>[+\-]?</code> や <code>(\+|-|)</code> を使えばいい(プラスかマイナスか何もないか、という意味になる)。</p>

<p><a class="p_ident" id="p_z4U70yP65+" href="#p_z4U70yP65+" tabindex="-1" role="presentation"></a>このエクササイズの複雑なところは、 <code>&quot;5.&quot;</code> と <code>&quot;.5&quot;</code> の両方にマッチさせるところだ( <code>&quot;.&quot;</code> にはマッチさせず)。ここで良い解決策になるのが <code>|</code> 演算子を使って2つの場合を分けることだ。つまり、1個以上の数字にオプションでドットと0個以上の数字が続く場合と、ドットに1つ以上の数字が続く場合だ。</p>

<p><a class="p_ident" id="p_WOazpBSh4J" href="#p_WOazpBSh4J" tabindex="-1" role="presentation"></a>最後に、 <em>e</em> の大文字と小文字を区別しなくなるように、正規表現に <code>i</code> オプションを加えるか、 <code>[eE]</code> を使おう。</p>

</div></div><nav><a href="08_error.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="10_modules.html" title="next chapter">▶</a></nav>
</article>
