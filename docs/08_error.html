<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>バグとエラー :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 8;var sandboxLoadFiles = ["code/chapter/08_error.js"];</script></head>

<article>
<nav><a href="07_robot.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="09_regexp.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 8</span>バグとエラー</h1>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>デバッグはコードを書くのに比べて倍は難しい。したがって、自分の賢さの限界を尽くして書いたコードは、定義上、デバッグ不可能だ。</p>

<footer>Brian Kernighan and P.J. Plauger, <cite>The Elements of Programming Style</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_8.jpg" alt="Picture of a collection of bugs"></figure>

<p>コンピュータプログラムの欠陥のことを <em>バグ</em> と呼ぶ。小虫がプログラムの中にたまたま入り込んだだけだとイメージする方が気楽だからだ。実際には、もちろん、自分でそこに仕込んでいる。</p>

<p><a class="p_ident" id="p_2kuSN7rMzf" href="#p_2kuSN7rMzf" tabindex="-1" role="presentation"></a>プログラムは思考が結晶化したものだとすると、バグは2種類に分類できる。思考自体の混乱によってできるものと、思考をコードに変換するときのミスによるものだ。たいていは前者の方が突き止めるのも直すのも難しい。</p>

<h2><a class="h_ident" id="h_Me7LPdxtqQ" href="#h_Me7LPdxtqQ" tabindex="-1" role="presentation"></a>言語</h2>

<p><a class="p_ident" id="p_78aDwuALBZ" href="#p_78aDwuALBZ" tabindex="-1" role="presentation"></a>コンピュータが我々を意図を知っていれば、たいていのミスを自動的に指摘してくれるはずだ。だけど、ここでJavaScriptのルーズさが邪魔になる。JavaScriptのバインディングやプロパティの概念はあいまいで、実際にプログラムを走らせてみるまでほとんどタイポを捕まえてもくれない。さらに、明らかに無意味な計算をさせても文句も言わない。例えば、 <code>true * &quot;monkey&quot;</code> のように。</p>

<p><a class="p_ident" id="p_6pVXVzGPFJ" href="#p_6pVXVzGPFJ" tabindex="-1" role="presentation"></a>JavaScriptが文句を言う場合もある。文法に従わないプログラムを書けば、すぐにコンピュータが文句を言う。他にも、関数ではないものを呼び出したり、undefined値のプロパティを見ようとしたりすれば、その操作を実行しようとしたときにエラーが起こって報告される。</p>

<p><a class="p_ident" id="p_1dTNB2FqVC" href="#p_1dTNB2FqVC" tabindex="-1" role="presentation"></a>でもありがちなのは、君のバカげた計算は単に <code>NaN</code> やundefinedを生み出すだけで、プログラムは意味があることをしているつもりで喜んで実行を続ける、ということだ。ミスは後になってから分かる。偽物の値がいくつもの関数を行き渡ってからだ。エラーを起こすこともなく、ひっそりとおかしいアウトプットを返してくるだけかもしれない。こういう問題の元を見つけるのは難しい。</p>

<p><a class="p_ident" id="p_SAOkiVUG6X" href="#p_SAOkiVUG6X" tabindex="-1" role="presentation"></a>こうしたプログラムのミス(バグ)を見つける作業を <em>デバッグ(debugging)</em> という。</p>

<h2><a class="h_ident" id="h_jZ+IHWqwWn" href="#h_jZ+IHWqwWn" tabindex="-1" role="presentation"></a>ストリクトモード(Strict mode)</h2>

<p><a class="p_ident" id="p_PRgG/j3Efm" href="#p_PRgG/j3Efm" tabindex="-1" role="presentation"></a>JavaScriptは <em>ストリクトモード(strict mode)</em> をオンにすると <em>少し</em> 厳格になる。ファイルや関数の頭に <code>&quot;use strict&quot;</code> を置くだけでオンにできる。以下はその例だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WqVH0qd4aL" href="#c_WqVH0qd4aL" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">canYouSpotTheProblem</span>() {
  <span class="cm-string">&quot;use strict&quot;</span>;
  <span class="cm-keyword">for</span> (<span class="cm-variable">counter</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">counter</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>; <span class="cm-variable">counter</span><span class="cm-operator">++</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Happy happy&quot;</span>);
  }
}

<span class="cm-variable">canYouSpotTheProblem</span>();
<span class="cm-comment">// → ReferenceError: counter is not defined(counterは定義されていない)</span></pre>

<p><a class="p_ident" id="p_7mIJI/9fxR" href="#p_7mIJI/9fxR" tabindex="-1" role="presentation"></a>普通は、 <code>let</code> をバインディングの前に置き忘れると( <code>counter</code> のように)、JavaScriptはひっそりとグローバルバインディングを作って使う。ストリクトモードならそこでエラーが発生する。これはとても便利だ。とはいえ注意しないといけないのは、問題のバインディングがすでにグローバルバインディングとして存在する場合だ。その場合は、やっぱり上のループはひっそりとグローバルバインディングを上書きする。</p>

<p>その他のストリクトモードの効果は、関数がメソッドとして呼び出されない限り <code>this</code> バインディングが <code>undefined</code> になることだ。ストリクトモード外でそういう呼び出しをした場合には、 <code>this</code> はグローバルオブジェクトを参照する。グローバルオブジェクトは、そのプロパティがグローバルバインディングになっているオブジェクトだ。もしストリクトモード内でメソッドやコンストラクターにおかしい呼び出し方をした場合は、JavaScriptが <code>this</code> のプロパティを読もうとしたときにエラーが起こるようになる。そして喜んでグローバルスコープに書き込むこともなくなる。</p>

<p>例えば、以下のコードについて考えてみよう。コンストラクター関数を <code>new</code> キーワードなしで呼び出しているから <code>this</code> は新しくできるオブジェクトを参照 <em>しない</em> 。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FPKrb2F1C3" href="#c_FPKrb2F1C3" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-keyword">let</span> <span class="cm-def">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">&quot;Ferdinand&quot;</span>); <span class="cm-comment">// oops</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">name</span>);
<span class="cm-comment">// → Ferdinand</span></pre>

<p><a class="p_ident" id="p_H7eBqJVJCK" href="#p_H7eBqJVJCK" tabindex="-1" role="presentation"></a>Personの間違った呼び出しが成功して、undefinedが返ってくる上に <code>name</code> というグローバルバインディングができてしまう。ストリクトモードでは結果が変わってくる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HFy5dGOOh4" href="#c_HFy5dGOOh4" tabindex="-1" role="presentation"></a><span class="cm-string">&quot;use strict&quot;</span>;
<span class="cm-keyword">function</span> <span class="cm-def">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-keyword">let</span> <span class="cm-def">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">&quot;Ferdinand&quot;</span>); <span class="cm-comment">// forgot new</span>
<span class="cm-comment">// → TypeError: Cannot set property 'name' of undefined</span></pre>

<p>すぐに何かがおかしいと教えてもらえる。これは便利だ。</p>

<p>幸い、 <code>class</code> 記法で作られたコンストラクターなら、 <code>new</code> なしで呼び出されると文句を言うからストリクトモードでなくてもあまり問題にならない。</p>

<p>ストリクトモードには他にもいくつか機能がある。関数に複数の同名のパラメーターを付けられないようにする。いくつかの問題があるJavaScriptの機能を取り去ってくれる( <code>with</code> など。これはあまりにも間違っているのでこの本ではもう扱わない)。</p>

<p>簡単にいえば、 <code>&quot;use strict&quot;</code> をプログラムの先頭におけば、邪魔になることはほとんどないし、問題を発見する手助けになるかもしれない。</p>

<h2><a class="h_ident" id="h_MQ8yNG/gKK" href="#h_MQ8yNG/gKK" tabindex="-1" role="presentation"></a>型(Types)</h2>

<p>言語によってはプログラム実行前にバインディングや式の型を知りたがるものもある。そういう言語は型が間違った使い方をされてるとすぐに教えてくれる。JavaScriptは実行するときだけ型について考えるし、その時にもこっそり値を予想する型に変換しようとするから、あまり助けにならない。</p>

<p>とはいえ、型はプログラムについて語るときには便利なフレームワークだ。ミスの多くは、関数に入れる値や出てくる値の種類についての混乱から起こるんだ。その情報を書いておけば、混乱する可能性は減るだろう。</p>

<p>前の章の <code>goalOrientedRobot</code> 関数に、次のようなコメントを書いて型について説明することもできるだろう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_30eJTz3eQP" href="#c_30eJTz3eQP" tabindex="-1" role="presentation"></a><span class="cm-comment">// (VillageState, Array) → {direction: string, memory: Array}</span>
<span class="cm-keyword">function</span> <span class="cm-def">goalOrientedRobot</span>(<span class="cm-def">state</span>, <span class="cm-def">memory</span>) {
  <span class="cm-comment">// ...</span>
}</pre>

<p>JavaScriptのプログラムに型で注釈を付ける方法にはいろいろな習慣がある。</p>

<p><a class="p_ident" id="p_FrxCjnDf90" href="#p_FrxCjnDf90" tabindex="-1" role="presentation"></a>型について1つ言えることは、それ自体が複雑さを持ち込むということだ。これはコードが使いやすくなるように十分な説明をするためなんだ。 配列からランダムな要素を返す <code>randomPick</code> 関数の型は何になるだろうか?君は <em>型変数(type variable)</em> , <em>T</em> を導入する必要があるかもしれない。 <em>T</em> はどんな型の代わりにもなる。だから、 <code>randomPick</code> の型は <code>([T]) -&gt; T</code> になるんだ(<em>T</em>の配列から<em>T</em>を1つ返す関数という意味になる)。</p>

<p id="typing"><a class="p_ident" id="p_JRyNyt+XY4" href="#p_JRyNyt+XY4" tabindex="-1" role="presentation"></a>プログラムの型が分かっているなら、コンピュータが <em>チェック</em> できるし、実行の前にミスを指摘することもできる。JavaScriptに型を加えてチェックできるようにした方言がいろいろある。一番有名なのは<a href="https://www.typescriptlang.org/">TypeScript</a>だ。これに興味があって、もっとプログラムを強固にしたかったら、試してみるといいだろう。</p>

<p>この本では、生の、危険な、型のないJavaScriptコードを使っていく。</p>

<h2><a class="h_ident" id="h_Y7Vg24hJ4I" href="#h_Y7Vg24hJ4I" tabindex="-1" role="presentation"></a>テスト</h2>

<p>言語がミスの発見を助けてくれないなら、地道に探していくしかない。つまりプログラムを実行して、正しい動作をしているか見ていくんだ。</p>

<p>これを何度も何度も手でやっていくのは、とても悪いアイデアだ。面倒くさいだけではなく、変更の度に徹底的に全てをテストするのは時間がかかりすぎるから、効率も悪い。</p>

<p>コンピュータは繰返しのタスクが得意で、テストは理想的な繰返しタスクだ。テストの自動化というのは、他のプログラムをテストするプログラムを書く、ということだ。テストを書くのは手動テストよりひと手間かかるけど、一度書いてしまえばちょっとした超能力が手に入ることになる。まず、テストで想定した状況に関してはプログラムがちゃんと動いていることが数秒で確認できるようになる。さらに、何かを壊してしまったらすぐに気づけるようになって、後になってみて問題に出くわすことがない。</p>

<p>テストはたいていラベル付きのプログラムの形式になっていて、コードの何かしらを確認する。例えば、 <code>toUpperCase</code> メソッド(標準のもの。たぶん誰かにテストされているだろう)のテストセットはこんな感じになるだろう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WrGyqyPbp3" href="#c_WrGyqyPbp3" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">test</span>(<span class="cm-def">label</span>, <span class="cm-def">body</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">body</span>()) <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failed: ${</span><span class="cm-variable-2">label</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
}

<span class="cm-variable">test</span>(<span class="cm-string">&quot;convert Latin text to uppercase&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;hello&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;HELLO&quot;</span>;
});
<span class="cm-variable">test</span>(<span class="cm-string">&quot;convert Greek text to uppercase&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;Χαίρετε&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;ΧΑΊΡΕΤΕ&quot;</span>;
});
<span class="cm-variable">test</span>(<span class="cm-string">&quot;don't convert case-less characters&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;مرحبا&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;مرحبا&quot;</span>;
});</pre>

<p>こんな風にテストを書くと、むしろしつこくてぎこちないコードになってしまう。幸い、テストの集合( <em>テストスイート</em> )を組み立てて実行するソフトウェアが存在する。それを使えば、テストを表現するのに適した言葉(関数やメソッドの形)で書けて、テストが失敗したときには意味のある情報をアウトプットしてくれる。これはたいてい <em>テストランナー</em> と呼ばれる。</p>

<p>あるコードが、他のコードよりテストしやすい、ということがある。一般的に、外部のオブジェクトとの関わりが多いコードほど、テストのための文脈のセットアップが大変になる。<a href="07_robot.html">前の章</a>で示したプログラミングのスタイル、つまり外部のオブジェクトを変更せずに自己完結した永続データを使うスタイルでは、テストが簡単になりやすい。</p>

<h2><a class="h_ident" id="h_k2QNrTrtgz" href="#h_k2QNrTrtgz" tabindex="-1" role="presentation"></a>デバッグ</h2>

<p>プログラムの挙動が変だったりエラーが出たりして、何かがおかしいと気づいたら、次のステップはその <em>何か</em> をつきとめることだ。</p>

<p>それが簡単な場合もある。エラーメッセージがプログラムのある行を指していて、エラーの説明とプログラムのその行を読めば分かってしまうような場合だ。</p>

<p>でも、いつでもそうなるとは限らない。問題が起こった行は、どこかで作られた壊れた値が、単に初めて使われただけの場合があるからだ。これまでの章のエクササイズを解いてきたなら、そういう状況を経験したことがあるだろう。</p>

<p><a class="p_ident" id="p_AGHCaI1vIH" href="#p_AGHCaI1vIH" tabindex="-1" role="presentation"></a>次の関数は、整数を、与えられた底(10進数、2進数などなど)で文字列に変換しようとする。繰返し最後の桁の数を取り出して、入力の数字を底で割ることでこの桁を捨てる。はずだけど、おかしな出力がバグの存在を示している。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8tOR9x4PzT" href="#c_8tOR9x4PzT" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">numberToString</span>(<span class="cm-def">n</span>, <span class="cm-def">base</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>, <span class="cm-def">sign</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">sign</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;-&quot;</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable-2">n</span>;
  }
  <span class="cm-keyword">do</span> {
    <span class="cm-variable-2">result</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">%</span> <span class="cm-variable-2">base</span>) <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">/=</span> <span class="cm-variable-2">base</span>;
  } <span class="cm-keyword">while</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">sign</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">numberToString</span>(<span class="cm-number">13</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3…</span></pre>

<p>既に問題が分かっていてもしばらく知らないフリをしてほしい。このプログラムが機能していないことは分かるけど、なぜかをつきとめていこう。</p>

<p>ここでランダムな変更を加えてよくなるかどうか見てみたい衝動に抵抗しよう。その代りに、 <em>考えるんだ</em> 。何が起こっているが分析して、どうしてそうなるのか理論を思いついてみよう。それから、その理論をテストするために追加で観察をしよう。あるいはまだ理論がないなら追加の観察によって何か思いつくかもしれない。</p>

<p>プログラムに戦略的に <code>console.log</code> を置いていくのも、プログラムの動作の情報を得るのにはいい戦略だ。この場合、 <code>n</code> の値が <code>13</code> , <code>1</code> , <code>0</code> と変化してほしい。ループの始めで <code>n</code> の値を書かせてみよう。</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_nB/OeL8UNa" href="#c_nB/OeL8UNa" tabindex="-1" role="presentation"></a>13
1.3
0.13
0.013
…
1.5e-323</pre>

<p><a class="p_ident" id="p_7GJjl4AIi9" href="#p_7GJjl4AIi9" tabindex="-1" role="presentation"></a><em>なるほど</em> 。13割る10が整数になっていない。 <code>n /= base</code> ではなくて、本当にほしいのは <code>n = Math.<wbr>floor(n /<wbr> base)</code> だ。こうすれば、桁がちゃんと右に &quot;シフトする&quot;。</p>

<p><a class="p_ident" id="p_qDI6Kps0rn" href="#p_qDI6Kps0rn" tabindex="-1" role="presentation"></a><code>console.log</code> 以外で、プログラムの挙動を調べる方法には、ブラウザーのデバッガー機能がある。ブラウザーには、コードの指定した場所にブレイクポイントを仕込む機能があるんだ。プログラムはブレイクポイントの行に達したら、一旦実行を停止するから、その時点でのバインディングの値を調べられる。デバッガーはブラウザーによってまちまちだからここでは詳しい話はしない。使っているブラウザーの開発者ツールを見たりやWebで調べてみたりするといい。</p>

<p>他にも <code>debugger</code> 宣言(単にこのキーワードだけの文)をプログラムに含めるとブレイクポイントを仕込むことができる。ブラウザーの開発者ツールがアクティブになっていれば、プログラムは <code>debugger</code> に到達したところで停止する。</p>

<h2><a class="h_ident" id="h_xV7f6EgZbK" href="#h_xV7f6EgZbK" tabindex="-1" role="presentation"></a>エラーの伝搬</h2>

<p>全ての問題がプログラマーによって防止できるわけではない、残念ながら。プログラムが外の世界とやりとりするなら、入力の形式がおかしいかもしれないし、過負荷状態になるかもしれないし、ネットワークの障害があるかもしれない。</p>

<p>プログラムが自分だけのものなら、そういう問題が起こるまで無視していてもいい。でも他の人も使うようなものを作るなら、単にクラッシュするよりはマシな対応をしたい。間違った入力を受け取ったとき、何も気にせず実行が続いた方がいい場合もあれば、ユーザーに問題を報告してギブアップした方がいい場合もある。ただ、どちらにしろプログラムは問題に対して主体的に対処するべきだ。</p>

<p><a class="p_ident" id="p_7w67t3KY4f" href="#p_7w67t3KY4f" tabindex="-1" role="presentation"></a>ユーザーに数字を要求して、それを返り値にする <code>promptNumber</code> という関数があるとしよう。ユーザーの入力が“orange”だったら何を返すべきだろう。</p>

<p><a class="p_ident" id="p_pD/MhHwik3" href="#p_pD/MhHwik3" tabindex="-1" role="presentation"></a>1つの選択肢としては、特別な値を返すことだ。一般的なのは <code>null</code> , <code>undefined</code> あるいは-1だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ssOc2pf47/" href="#c_ssOc2pf47/" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">promptNumber</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable">Number</span>.<span class="cm-property">isNaN</span>(<span class="cm-variable-2">result</span>)) <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">promptNumber</span>(<span class="cm-string">&quot;How many trees do you see?&quot;</span>));</pre>

<p><code>promptNumber</code> を呼び出す関数は、本当の数字が返ってきたかチェックして、失敗だったらなんとかリカバーしないといけない。また聞いたり、デフォルト値で埋めたりすることになるだろう。もしくは、さらに <em>その</em> 呼び出し元に特別な値を返して、要求に失敗したと伝えるかだ。</p>

<p>たいていの状況で、特にエラーが起こりやすく呼び出し元がそれを計算に入れるべきときには、特別な値を返す事がエラーを示すには良い方法だ。とはいえ、ここには欠点もある。まず、そもそもの関数がどんな値でも返し得るものだったらどうだろう?そういう関数では成功と失敗を見分けるために、結果をオブジェクトに包むようなことをしないといけない。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_aQW8dfZcRx" href="#c_aQW8dfZcRx" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">lastElement</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">return</span> {<span class="cm-property">failed</span>: <span class="cm-atom">true</span>};
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> {<span class="cm-property">element</span>: <span class="cm-variable-2">array</span>[<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>]};
  }
}</pre>

<p><a class="p_ident" id="p_96uAUcJUq/" href="#p_96uAUcJUq/" tabindex="-1" role="presentation"></a>特別な値を返すことの2つ目の問題は、わずらわしいコードになりかねないことだ。あるコードが <code>promptNumber</code> を10回呼び出すなら <code>null</code> が返されていないか10回チェックすることになる。その上、 <code>null</code> を見つけたときの反応として、そのコードもまた <code>null</code> を返すなら、その呼び出し元がまたチェックしないといけない。</p>

<h2><a class="h_ident" id="h_j415hnLO9o" href="#h_j415hnLO9o" tabindex="-1" role="presentation"></a>例外(Exceptions)</h2>

<p><a class="p_ident" id="p_inz/P47QgH" href="#p_inz/P47QgH" tabindex="-1" role="presentation"></a>ある関数が通常通り実行を続けていけないときには、実行を止めて問題への対処方法が分かっている場所へすぐにジャンプできれば <em>うれしい</em> 。これが <em>例外処理(exception handling)</em> のすることだ。</p>

<p><a class="p_ident" id="p_Z9GcELQVxl" href="#p_Z9GcELQVxl" tabindex="-1" role="presentation"></a>例外とは、コードが問題にぶつかったときに例外を <em>発生させる(raise)</em> (もしくは <em>投げる(throw)</em> )メカニズムのことだ。例外はどういう値でも取り得る。例外を発生させるのは、関数からの超強力なreturnみたいなものだ。現在の関数だけではなく、その呼び出し元も飛び出して、実行が始まった初めの呼び出しまで戻る。これを <em>スタックの巻き戻し</em> という。<a href="03_functions.html#stack">3</a>章での関数呼び出しのスタックを覚えているだろう。例外はこのスタックを急降下していって、呼び出しのコンテキストを全て捨てていく。</p>

<p>もし例外が常にスタックの一番下まで急降下していくなら、あまり使い道はないだろう。ただプログラムの壊れ方が新しくなっただけだ。例外のパワーは、例外を <em>キャッチする</em> ためにスタックに障害物を置けるところにある。例外をキャッチしてしまえば、問題に対処するために何かしらできるし、プログラムの実行を継続できる。</p>

<p>これがその例だ。</p>

<pre id="look" class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0VA94HjY2e" href="#c_0VA94HjY2e" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;left&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;L&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;right&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;R&quot;</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Invalid direction: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}

<span class="cm-keyword">function</span> <span class="cm-def">look</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-variable">promptDirection</span>(<span class="cm-string">&quot;Which way?&quot;</span>) <span class="cm-operator">==</span> <span class="cm-string">&quot;L&quot;</span>) {
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;a house&quot;</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;two angry bears&quot;</span>;
  }
}

<span class="cm-keyword">try</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You see&quot;</span>, <span class="cm-variable">look</span>());
} <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Something went wrong: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
}</pre>

<p><code>throw</code> キーワードは例外を発生させるために使われる。例外をキャッチするにはコードを <code>try</code> ブロックで囲んで、 <code>catch</code> キーワードを続ければいい。 <code>try</code> ブロック内で例外が発生すれば、 <code>catch</code> ブロックが評価される。このとき、カッコ内の名前に例外値がバインドされる。 <code>catch</code> ブロックが終わるか、 <code>try</code> ブロックが問題なく終わるかすれば、 <code>try/catch</code> 宣言の次へプログラムは進んでいく。</p>

<p>上の例では <code>Error</code> コンストラクターでオリジナルの例外の値を作っている。これはJavaScript標準のコンストラクターで、 <code>message</code> プロパティを持つオブジェクトを作る。たいていのJavaScript実行環境では、このコンストラクターは例外が作られた瞬間のコールスタックの情報( <em>スタックトレース</em> )も収集する。この情報は <code>stack</code> プロパティに保存されて、デバッグの助けになる。問題の起こった関数や呼び出しを失敗した関数を教えてくれるからだ。</p>

<p><code>look</code> 関数では <code>promptDirection</code> が失敗する可能性を完全に無視しているしていることに注目してほしい。これが例外の大きなアドバンテージだ。エラーを処理するコードは、エラーが起こる場所とエラーを処理する場所でだけ必要になる。間にある関数はエラー処理のことはすっかり忘れていい。</p>

<p>いや、ほとんど忘れていい...</p>

<h2><a class="h_ident" id="h_SjKwbWeEmn" href="#h_SjKwbWeEmn" tabindex="-1" role="presentation"></a>例外の後片付け</h2>

<p>例外の効果は新しい種類の制御フローともいえる。例外を起こしかねないコードは全て、その時点のコードから制御を離脱させてしまうかもしれないからだ。ほとんど全ての関数の呼び出しやプロパティへのアクセスも例外を起こしかねないのだけど。</p>

<p>これは、コードにいくつか副作用がある場合には、一見その&quot;普通&quot;の制御フローが全て実行されるように見えても、例外がどこかで実行を妨げるかもしれないということだ。</p>

<p>以下はひどい銀行口座のコードだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_e3XosnGG47" href="#c_e3XosnGG47" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">accounts</span> <span class="cm-operator">=</span> {
  <span class="cm-property">a</span>: <span class="cm-number">100</span>,
  <span class="cm-property">b</span>: <span class="cm-number">0</span>,
  <span class="cm-property">c</span>: <span class="cm-number">20</span>
};

<span class="cm-keyword">function</span> <span class="cm-def">getAccount</span>() {
  <span class="cm-keyword">let</span> <span class="cm-def">accountName</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-string">&quot;Enter an account name&quot;</span>);
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">accounts</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">accountName</span>)) {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string-2">`No such account: ${</span><span class="cm-variable-2">accountName</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">accountName</span>;
}

<span class="cm-keyword">function</span> <span class="cm-def">transfer</span>(<span class="cm-def">from</span>, <span class="cm-def">amount</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">&lt;</span> <span class="cm-variable-2">amount</span>) <span class="cm-keyword">return</span>;
  <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">-=</span> <span class="cm-variable-2">amount</span>;
  <span class="cm-variable">accounts</span>[<span class="cm-variable">getAccount</span>()] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
}</pre>

<p><code>transfer</code> 関数は引数の銀行口座から、もう一方の口座にお金を移す。もう一方の口座は実行の途中に聞く。聞いた名前が無効な口座名だったら <code>getAccount</code> 関数は例外を発生させる。</p>

<p>ここで <code>transfer</code> 関数は <em>最初に</em> 口座からお金を引き出して、 <em>その後で</em> もう一方に移す前に <code>getAccount</code> 関数を呼び出している。 <code>getAccount</code> 関数が例外を発生してしまうと、ただお金が消滅するだけになる。</p>

<p>上のコードはもう少し賢く書くことができるだろう。例えば、お金を移動する前に <code>getAccount</code> 関数を呼ぶとか。でも、こういう問題は実際にはもっとひっそりと起こる。例外を投げなさそうな関数が、例外的な状況やプログラマーのミスのせいで例外を発生させる。</p>

<p><a class="p_ident" id="p_NWoZK3kTsE" href="#p_NWoZK3kTsE" tabindex="-1" role="presentation"></a>1つの対処方は、副作用をなるべく使わないことだ。ここでも、元のデータを変更せずに新しい値を計算するというプログラミングスタイルが助けになるんだ。新しいコードを作っている最中にコードの実行が停止しても、誰もその中途半端な値を見なければ、何も問題はない。</p>

<p>とはいえ、そのスタイルがいつでも実践できるとは限らない。そこで <code>try</code> 文のもう1つの機能がある。 <code>try</code> ブロックには、 <code>catch</code> ブロックに置き換えて(もしくは後に加えるか、どちらでもいい)、 <code>finally</code> ブロックを続けることができる。 <code>finally</code> ブロックの主張は、&quot; <code>try</code> ブロックのコードを実行しようとした後で、 <em>何が起きても</em> このコードを実行しろ&quot;、ということだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_brWpzDAy4+" href="#c_brWpzDAy4+" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">transfer</span>(<span class="cm-def">from</span>, <span class="cm-def">amount</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">&lt;</span> <span class="cm-variable-2">amount</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">progress</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">-=</span> <span class="cm-variable-2">amount</span>;
    <span class="cm-variable-2">progress</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
    <span class="cm-variable">accounts</span>[<span class="cm-variable">getAccount</span>()] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
    <span class="cm-variable-2">progress</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>;
  } <span class="cm-keyword">finally</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">progress</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
    }
  }
}</pre>

<p>今度の <code>transfer</code> 関数は、進行を追跡する。そしてもし、終了するときに、おかしい状態を作ってしまったことに気づけば、作ってしまったダメージを修復する。</p>

<p><code>try</code> ブロックで例外が発生した後に、 <code>finally</code> コードが実行されるとしてもそこで例外の処理を行っていないことに注目してほしい。 <code>finally</code> の実行が終わった後で、スタックの巻き戻しが続く。</p>

<p>例外が予想もしないところで起こるようなときにも確実に動作するプログラムを書くのは難しい。例外が起きるのはあくまで例外的な状況だから、問題が起こるのは気づかれもしないし、手当てもされないことも多い。これが良い事か悪い事かはソフトウェアの障害がどんなダメージを起こすかによる。</p>

<h2><a class="h_ident" id="h_HGrxZvwS3K" href="#h_HGrxZvwS3K" tabindex="-1" role="presentation"></a>選択的エラー処理</h2>

<p><a class="p_ident" id="p_PMsZnbelwD" href="#p_PMsZnbelwD" tabindex="-1" role="presentation"></a>例外がキャッチされずにスタックの一番下まで行ってしまうと、環境によって処理される。何か起こるかは環境によって違う。ブラウザーではだいたいエラーはJavaScriptコンソールに表示される(ブラウザーの開発者ツールでアクセスできる)。Node.jsはブラウザ外のJavaScript環境で、詳しくは<a href="20_node.html">20</a>章で扱うが、データの漏れ出しについてはもう少し注意深い。処理されない例外が起こったときにはプログラム全体の実行を止めるんだ。</p>

<p>プログラマーのミスに関しては、エラーが環境まで達するのを黙って見ているしかない。処理されていない例外はプログラムが壊れているシグナルで、モダンブラウザーのJavaScriptコンソールは、どの関数の呼び出しで問題が起こったか教えてくれる。</p>

<p>ルーティーンでの使用で発生が <em>予想できる</em> 問題では、例外を処理しないでクラッシュするのはひどい戦略だ。</p>

<p>存在しないバインディングを参照しようとする、 <code>null</code> のプロパティを見ようとする、関数ではないのに呼び出そうとする、など言語の使い方が間違っている場合にも例外は発生する。この例外もキャッチできるはずだ。</p>

<p><code>catch</code> ブロックに入ったとき、分かることは <code>try</code> ブロックで何かが例外を起こしたことだけだ。しかし、何がどの例外を起こしたかは分からない。</p>

<p>JavaScriptは(明白な欠陥で)、例外の種類を選んでキャッチする方法を(直接は)持っていない。全てキャッチするか、どれもしないかなんだ。このせいで、実際にキャッチする例外が、 <code>catch</code> ブロックを書いているときに <em>想定している</em> 例外だと思いたくなる。</p>

<p>でも、そうではないかもしれない。他の部分で想定が崩れるかもしれないし、他に例外を発生させるバグを仕込んでしまっているかもしれない。以下は、有効な回答を得るまで <code>promptDirection</code> 関数を呼び出し続け <em>ようとする</em> 例だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZxDKrGLCQ3" href="#c_ZxDKrGLCQ3" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promtDirection</span>(<span class="cm-string">&quot;Where?&quot;</span>); <span class="cm-comment">// ← typo!</span>
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You chose &quot;</span>, <span class="cm-variable-2">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Not a valid direction. Try again.&quot;</span>);
  }
}</pre>

<p><a class="p_ident" id="p_+OpeYcr13V" href="#p_+OpeYcr13V" tabindex="-1" role="presentation"></a>ここで <code>for (;;)</code> はあえて無限ループを作っている。有効な方向が入力された場合だけ、ループを抜けるようにしているんだ。 <em>だけど</em> 、 <code>promptDirection</code> をスペルミスしているせいで、“undefined variable”エラーが起こってしまう。 <code>catch</code> ブロックは例外の値( <code>e</code> )を完全に無視しているから、バインディングに関するエラーをインプットの間違いとして扱ってしまう。これでは無限ループを起こす上に、バインディングのスペルミスに関する有効なエラーメッセージを埋もれさせてしまう。</p>

<p>一般的なルールとして、例外をどこかに&quot;中継する&quot;目的ではない限り無闇にキャッチするのはやめよう。中継とは例えば、ネットワーク上の他のシステムにプログラムがクラッシュしたことを伝えるようなことだ。そうするとしても情報を隠してしまっていないか注意するようにしよう。</p>

<p>というわけで <em>特定の</em> 種類の例外をキャッチするようにしたい。 <code>catch</code> ブロックで、その例外が興味を持っているものかどうかチェックして、違ったらまた放り投げてしまおう。だけど、どうすれば例外を認識できる?</p>

<p>例外の <code>message</code> プロパティと、発生が予測できるエラーメッセージと比べてもいいだろう。ただ、これはあやういコードだ。人間が読むための情報(メッセージ)でプログラム上の決定をすることになる。だれかがメッセージを変えた(あるいは翻訳した)途端に、そのコードは動かなくなる。</p>

<p>それよりは新しいタイプのエラーを定義して、 <code>instanceof</code> でそれを識別するようにしよう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_miFD8lvrWj" href="#c_miFD8lvrWj" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">InputError</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;left&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;L&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;right&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;R&quot;</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">InputError</span>(<span class="cm-string">&quot;Invalid direction: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}</pre>

<p>新しいエラークラスは <code>Error</code> を継承している。このクラスにはコンストラクターさえ定義しないで、文字列を引数にとる <code>Error</code> コンストラクターを継承する。実際のところ、このクラスは何も定義していない空のクラスだ。 <code>InputError</code> オブジェクトは <code>Error</code> オブジェクトと同じふるまいをする。ただ、クラスだけが違っていて、それで識別することができるんだ。</p>

<p>上のループの例ではもっと注意深くキャッチできるようになった。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ab/mR1C1nr" href="#c_ab/mR1C1nr" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promptDirection</span>(<span class="cm-string">&quot;Where?&quot;</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You chose &quot;</span>, <span class="cm-variable-2">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">InputError</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Not a valid direction. Try again.&quot;</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">throw</span> <span class="cm-variable-2">e</span>;
    }
  }
}</pre>

<p>ここでは <code>InputError</code> のインスタンスだけがキャッチされて、関係ない例外は素通りする。タイプミスしたとしても、undefinedバインディングのエラーはしっかりと報告される。</p>

<h2><a class="h_ident" id="h_PZtfqmRphE" href="#h_PZtfqmRphE" tabindex="-1" role="presentation"></a>アサーション(Assertions)</h2>

<p><a class="p_ident" id="p_Sb9V3BEus1" href="#p_Sb9V3BEus1" tabindex="-1" role="presentation"></a><em>アサーション(Assertions)</em> とは、プログラム中の何かが、あるべき形をとっているか確認することだ。普通の操作で出会う状況を処理するためにではなく、プログラマーのミスを見つけるために使われる。</p>

<p>もし、例えば <code>firstElement</code> 関数を空の配列に対して呼び出すべきではない関数として定義するなら、以下のように書けるだろう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gRlHo3tyh8" href="#c_gRlHo3tyh8" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">firstElement</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;firstElement called with []&quot;</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>[<span class="cm-number">0</span>];
}</pre>

<p>これでこの関数は使い方を間違えたときに、ひっそりとundefinedを返すのはなく、音を立てて吹き飛ぶようになった。こうすれば、ミスが気づかれないままになりづらく、起こったときには原因を見つけやすい。</p>

<p>全ての可能性に対してアサーションを書こうとするのはオススメしない。大変な作業だし、ひどく雑然としたコードができるだろう。アサーションは、犯しがちなミスにとっておこう(あるいは実際にしたこと)。</p>

<h2><a class="h_ident" id="h_WvYIPtb9vj" href="#h_WvYIPtb9vj" tabindex="-1" role="presentation"></a>まとめ</h2>

<p>ミスや間違った入力は、生活の現実だ。プログラミングの重要な部分はバグを見つけ、診断し、直すことだ。自動化されたテストスイートやアサーションを導入すれば、問題に気づくのが簡単になる。</p>

<p>プログラム制御の外部要因が起こす問題には、優雅に対処しないといけない。問題がローカルに処理できるときには、特別な返り値を使うと分かりやすいときもある。そうでなければ、たぶん例外を使うといいだろう。</p>

<p>例外を発生させるとコールスタックは次の <code>try/catch</code> ブロックかスタックの最底辺まで巻き戻ってしまう。 <code>catch</code> ブロックには例外の値が渡されて、そこで予想された種類の例外かどうかチェックされて、それから対処されないといけない。例外によって起こされる予測不能な制御フローに対処するために、 <code>finally</code> ブロックを使えば、あるコードを <em>常に</em> 実行することができる。</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>Exercises</h2>

<h3><a class="i_ident" id="i_n1zYouiAfX" href="#i_n1zYouiAfX" tabindex="-1" role="presentation"></a>Retry</h3>

<p>リトライ</p>

<p><a class="p_ident" id="p_Wx0K5jjW/Z" href="#p_Wx0K5jjW/Z" tabindex="-1" role="presentation"></a><code>primitiveMultiply</code> という関数があって、20パーセントの確立で2つの数をかけて、80パーセントの確立で <code>MultiplicatorUnitFailure</code> というエラーを発生させるとしよう。このブサイクな関数をラップして、成功するまで呼び出しを続けてから、結果を返す関数を書こう。</p>

<p>処理しようとする例外だけを扱うようにしよう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_E1Acr2VS8k" href="#c_E1Acr2VS8k" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">MultiplicatorUnitFailure</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">primitiveMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">&lt;</span> <span class="cm-number">0.2</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">MultiplicatorUnitFailure</span>(<span class="cm-string">&quot;Klunk&quot;</span>);
  }
}

<span class="cm-keyword">function</span> <span class="cm-def">reliableMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reliableMultiply</span>(<span class="cm-number">8</span>, <span class="cm-number">8</span>));
<span class="cm-comment">// → 64</span></pre>

<div class="solution"><div class="solution-text">

<p><code>primitiveMultiply</code> 関数の呼び出しは絶対に <code>try</code> ブロックの中で起こるべきだ。対応する <code>catch</code> ブロックは、例外が <code>MultiplicatorUnitFailure</code> のインスタンスの場合には、さらに例外を発生させる。このエラーだった場合には、呼び出しにリトライする。</p>

<p>リトライのためには、呼び出しが成功した場合にだけ停止するループを書いてもいい(この章の<a href="08_error.html#look"> <code>look</code> の例</a>のように)。または、失敗が続きすぎてスタックがオーバーフローしないことを願いながら(実際には安全な賭けだ)、再帰を使ってもいい。</p>

</div></div>

<h3><a class="i_ident" id="i_iGlwnUbkRs" href="#i_iGlwnUbkRs" tabindex="-1" role="presentation"></a>The locked box</h3>

<p>ロックされた箱</p>

<p>次のような(わざとらしい)オブジェクトを考えてみよう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_X963W9SHCK" href="#c_X963W9SHCK" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">box</span> <span class="cm-operator">=</span> {
  <span class="cm-property">locked</span>: <span class="cm-atom">true</span>,
  <span class="cm-property">unlock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>; },
  <span class="cm-property">lock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;  },
  <span class="cm-property">_content</span>: [],
  <span class="cm-property">get</span> <span class="cm-property">content</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">locked</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Locked!&quot;</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">_content</span>;
  }
};</pre>

<p>これはロックのかかった箱だ。箱の中には配列があるけど、ロックが外れているときしかアクセスできないんだ。プライベートの <code>_content</code> プロパティに直接アクセスするのは禁止されている。</p>

<p><code>withBoxUnlocked</code> という関数を書いてみよう。この関数は、引数として関数値を受け取って、箱のロックを外してから、受け取った関数を実行して、実行を終える前には箱がまた確実にロックされているようにする。引数の関数が普通に終わっても例外を発生させてもだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EPN4Aey63n" href="#c_EPN4Aey63n" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">box</span> <span class="cm-operator">=</span> {
  <span class="cm-property">locked</span>: <span class="cm-atom">true</span>,
  <span class="cm-property">unlock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>; },
  <span class="cm-property">lock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;  },
  <span class="cm-property">_content</span>: [],
  <span class="cm-property">get</span> <span class="cm-property">content</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">locked</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Locked!&quot;</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">_content</span>;
  }
};

<span class="cm-keyword">function</span> <span class="cm-def">withBoxUnlocked</span>(<span class="cm-def">body</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">box</span>.<span class="cm-property">content</span>.<span class="cm-property">push</span>(<span class="cm-string">&quot;gold piece&quot;</span>);
});

<span class="cm-keyword">try</span> {
  <span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Pirates on the horizon! Abort!&quot;</span>);
  });
} <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Error raised: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">e</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">box</span>.<span class="cm-property">locked</span>);
<span class="cm-comment">// → true</span></pre>

<p>おまけとして、 <code>withBoxUnlocked</code> 関数を呼び出したときに、すでに箱のロックが外れているなら、外れたままにしておこう。</p>

<div class="solution"><div class="solution-text">

<p>このエクササイズには <code>finally</code> ブロックが必要になる。君の関数は、まず箱のロックを外して、それから <code>try</code> ブロックの中で引数の関数を呼び出す。その後に続く <code>finally</code> ブロックで、箱にロックをかけないといけない。</p>

<p>箱がロックされていない場合に、箱をロックしないようにするためには、関数の始めでロックをチェックして、ロックされている場合にだけ、外してからまたかけることにすればいい。</p>

</div></div><nav><a href="07_robot.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="09_regexp.html" title="next chapter">▶</a></nav>
</article>
