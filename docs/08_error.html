<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>バグとエラー :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 8;var sandboxLoadFiles = ["code/chapter/08_error.js"];</script></head>

<article>
<nav><a href="07_robot.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="09_regexp.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 8</span>バグとエラー</h1>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>デバッグはコードを書くのに比べて倍は難しい。したがって、自分の賢さの限界を尽くして書いたコードは、定義上、デバッグ不可能だ。</p>

<footer>Brian Kernighan and P.J. Plauger, <cite>The Elements of Programming Style</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_8.jpg" alt="Picture of a collection of bugs"></figure>

<p>コンピュータプログラムの欠陥のことを <em>バグ</em> と呼ぶ。小虫がプログラムの中にたまたま入り込んだだけだとイメージする方が気楽だからだ。実際には、もちろん、自分でそこに仕込んでいる。</p>

<p><a class="p_ident" id="p_2kuSN7rMzf" href="#p_2kuSN7rMzf" tabindex="-1" role="presentation"></a>プログラムは思考が結晶化したものだとすると、バグは2種類に分類できる。思考自体の混乱によってできるものと、思考をコードに変換するときのミスによるものだ。たいていは前者の方が突き止めるのも直すのも難しい。</p>

<h2><a class="h_ident" id="h_Me7LPdxtqQ" href="#h_Me7LPdxtqQ" tabindex="-1" role="presentation"></a>言語</h2>

<p><a class="p_ident" id="p_78aDwuALBZ" href="#p_78aDwuALBZ" tabindex="-1" role="presentation"></a>コンピュータが我々を意図を知っていれば、たいていのミスを自動的に指摘してくれるはずだ。だけど、ここでJavaScriptのルーズさが邪魔になる。JavaScriptのバインディングやプロパティの概念はあいまいで、実際にプログラムを走らせてみるまでほとんどタイポを捕まえてもくれない。さらに、明らかに無意味な計算をさせても文句も言わない。例えば、 <code>true * &quot;monkey&quot;</code> のように。</p>

<p><a class="p_ident" id="p_6pVXVzGPFJ" href="#p_6pVXVzGPFJ" tabindex="-1" role="presentation"></a>JavaScriptが文句を言う場合もある。文法に従わないプログラムを書けば、すぐにコンピュータが文句を言う。他にも、関数ではないものを呼び出したり、undefined値のプロパティを見ようとしたりすれば、その操作を実行しようとしたときにエラーが起こって報告される。</p>

<p><a class="p_ident" id="p_1dTNB2FqVC" href="#p_1dTNB2FqVC" tabindex="-1" role="presentation"></a>でもありがちなのは、君のバカげた計算は単に <code>NaN</code> やundefinedを生み出すだけで、プログラムは意味があることをしているつもりで喜んで実行を続ける、ということだ。ミスは後になってから分かる。偽物の値がいくつもの関数を行き渡ってからだ。エラーを起こすこともなく、ひっそりとおかしいアウトプットを返してくるだけかもしれない。こういう問題の元を見つけるのは難しい。</p>

<p><a class="p_ident" id="p_SAOkiVUG6X" href="#p_SAOkiVUG6X" tabindex="-1" role="presentation"></a>こうしたプログラムのミス(バグ)を見つける作業を <em>デバッグ(debugging)</em> という。</p>

<h2><a class="h_ident" id="h_jZ+IHWqwWn" href="#h_jZ+IHWqwWn" tabindex="-1" role="presentation"></a>ストリクトモード(Strict mode)</h2>

<p><a class="p_ident" id="p_PRgG/j3Efm" href="#p_PRgG/j3Efm" tabindex="-1" role="presentation"></a>JavaScriptは <em>ストリクトモード(strict mode)</em> をオンにすると <em>少し</em> 厳格になる。ファイルや関数の頭に <code>&quot;use strict&quot;</code> を置くだけでオンにできる。以下はその例だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WqVH0qd4aL" href="#c_WqVH0qd4aL" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">canYouSpotTheProblem</span>() {
  <span class="cm-string">&quot;use strict&quot;</span>;
  <span class="cm-keyword">for</span> (<span class="cm-variable">counter</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">counter</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>; <span class="cm-variable">counter</span><span class="cm-operator">++</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Happy happy&quot;</span>);
  }
}

<span class="cm-variable">canYouSpotTheProblem</span>();
<span class="cm-comment">// → ReferenceError: counter is not defined(counterは定義されていない)</span></pre>

<p><a class="p_ident" id="p_7mIJI/9fxR" href="#p_7mIJI/9fxR" tabindex="-1" role="presentation"></a>普通は、 <code>let</code> をバインディングの前に置き忘れると( <code>counter</code> のように)、JavaScriptはひっそりとグローバルバインディングを作って使う。ストリクトモードならそこでエラーが発生する。これはとても便利だ。とはいえ注意しないといけないのは、問題のバインディングがすでにグローバルバインディングとして存在する場合だ。その場合は、やっぱり上のループはひっそりとグローバルバインディングを上書きする。</p>

<p>その他のストリクトモードの効果は、関数がメソッドとして呼び出されない限り <code>this</code> バインディングが <code>undefined</code> になることだ。ストリクトモード外でそういう呼び出しをした場合には、 <code>this</code> はグローバルオブジェクトを参照する。グローバルオブジェクトは、そのプロパティがグローバルバインディングになっているオブジェクトだ。もしストリクトモード内でメソッドやコンストラクターにおかしい呼び出し方をした場合は、JavaScriptが <code>this</code> のプロパティを読もうとしたときにエラーが起こるようになる。そして喜んでグローバルスコープに書き込むこともなくなる。</p>

<p>例えば、以下のコードについて考えてみよう。コンストラクター関数を <code>new</code> キーワードなしで呼び出しているから <code>this</code> は新しくできるオブジェクトを参照 <em>しない</em> 。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FPKrb2F1C3" href="#c_FPKrb2F1C3" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-keyword">let</span> <span class="cm-def">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">&quot;Ferdinand&quot;</span>); <span class="cm-comment">// oops</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">name</span>);
<span class="cm-comment">// → Ferdinand</span></pre>

<p><a class="p_ident" id="p_H7eBqJVJCK" href="#p_H7eBqJVJCK" tabindex="-1" role="presentation"></a>Personの間違った呼び出しが成功して、undefinedが返ってくる上に <code>name</code> というグローバルバインディングができてしまう。ストリクトモードでは結果が変わってくる。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HFy5dGOOh4" href="#c_HFy5dGOOh4" tabindex="-1" role="presentation"></a><span class="cm-string">&quot;use strict&quot;</span>;
<span class="cm-keyword">function</span> <span class="cm-def">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-keyword">let</span> <span class="cm-def">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">&quot;Ferdinand&quot;</span>); <span class="cm-comment">// forgot new</span>
<span class="cm-comment">// → TypeError: Cannot set property 'name' of undefined</span></pre>

<p>すぐに何かがおかしいと教えてもらえる。これは便利だ。</p>

<p>幸い、 <code>class</code> 記法で作られたコンストラクターなら、 <code>new</code> なしで呼び出されると文句を言うからストリクトモードでなくてもあまり問題にならない。</p>

<p>ストリクトモードには他にもいくつか機能がある。関数に複数の同名のパラメーターを付けられないようにする。いくつかの問題があるJavaScriptの機能を取り去ってくれる( <code>with</code> など。これはあまりにも間違っているのでこの本ではもう扱わない)。</p>

<p>簡単にいえば、 <code>&quot;use strict&quot;</code> をプログラムの先頭におけば、邪魔になることはほとんどないし、問題を発見する手助けになるかもしれない。</p>

<h2><a class="h_ident" id="h_MQ8yNG/gKK" href="#h_MQ8yNG/gKK" tabindex="-1" role="presentation"></a>型(Types)</h2>

<p>言語によってはプログラム実行前にバインディングや式の型を知りたがるものもある。そういう言語は型が間違った使い方をされてるとすぐに教えてくれる。JavaScriptは実行するときだけ型について考えるし、その時にもこっそり値を予想する型に変換しようとするから、あまり助けにならない。</p>

<p>とはいえ、型はプログラムについて語るときには便利なフレームワークだ。ミスの多くは、関数に入れる値や出てくる値の種類についての混乱から起こるんだ。その情報を書いておけば、混乱する可能性は減るだろう。</p>

<p>前の章の <code>goalOrientedRobot</code> 関数に、次のようなコメントを書いて型について説明することもできるだろう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_30eJTz3eQP" href="#c_30eJTz3eQP" tabindex="-1" role="presentation"></a><span class="cm-comment">// (VillageState, Array) → {direction: string, memory: Array}</span>
<span class="cm-keyword">function</span> <span class="cm-def">goalOrientedRobot</span>(<span class="cm-def">state</span>, <span class="cm-def">memory</span>) {
  <span class="cm-comment">// ...</span>
}</pre>

<p>JavaScriptのプログラムに型で注釈を付ける方法にはいろいろな習慣がある。</p>

<p><a class="p_ident" id="p_FrxCjnDf90" href="#p_FrxCjnDf90" tabindex="-1" role="presentation"></a>型について1つ言えることは、それ自体が複雑さを持ち込むということだ。これはコードが使いやすくなるように十分な説明をするためなんだ。 配列からランダムな要素を返す <code>randomPick</code> 関数の型は何になるだろうか?君は <em>型変数(type variable)</em> , <em>T</em> を導入する必要があるかもしれない。 <em>T</em> はどんな型の代わりにもなる。だから、 <code>randomPick</code> の型は <code>([T]) -&gt; T</code> になるんだ(<em>T</em>の配列から<em>T</em>を1つ返す関数という意味になる)。</p>

<p id="typing"><a class="p_ident" id="p_JRyNyt+XY4" href="#p_JRyNyt+XY4" tabindex="-1" role="presentation"></a>プログラムの型が分かっているなら、コンピュータが <em>チェック</em> できるし、実行の前にミスを指摘することもできる。JavaScriptに型を加えてチェックできるようにした方言がいろいろある。一番有名なのは<a href="https://www.typescriptlang.org/">TypeScript</a>だ。これに興味があって、もっとプログラムを強固にしたかったら、試してみるといいだろう。</p>

<p>この本では、生の、危険な、型のないJavaScriptコードを使っていく。</p>

<h2><a class="h_ident" id="h_Y7Vg24hJ4I" href="#h_Y7Vg24hJ4I" tabindex="-1" role="presentation"></a>テスト</h2>

<p>言語がミスの発見を助けてくれないなら、地道に探していくしかない。つまりプログラムを実行して、正しい動作をしているか見ていくんだ。</p>

<p>これを何度も何度も手でやっていくのは、とても悪いアイデアだ。面倒くさいだけではなく、変更の度に徹底的に全てをテストするのは時間がかかりすぎるから、効率も悪い。</p>

<p>コンピュータは繰返しのタスクが得意で、テストは理想的な繰返しタスクだ。テストの自動化というのは、他のプログラムをテストするプログラムを書く、ということだ。テストを書くのは手動テストよりひと手間かかるけど、一度書いてしまえばちょっとした超能力が手に入ることになる。まず、テストで想定した状況に関してはプログラムがちゃんと動いていることが数秒で確認できるようになる。さらに、何かを壊してしまったらすぐに気づけるようになって、後になってみて問題に出くわすことがない。</p>

<p>テストはたいていラベル付きのプログラムの形式になっていて、コードの何かしらを確認する。例えば、 <code>toUpperCase</code> メソッド(標準のもの。たぶん誰かにテストされているだろう)のテストセットはこんな感じになるだろう。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WrGyqyPbp3" href="#c_WrGyqyPbp3" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">test</span>(<span class="cm-def">label</span>, <span class="cm-def">body</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">body</span>()) <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failed: ${</span><span class="cm-variable-2">label</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
}

<span class="cm-variable">test</span>(<span class="cm-string">&quot;convert Latin text to uppercase&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;hello&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;HELLO&quot;</span>;
});
<span class="cm-variable">test</span>(<span class="cm-string">&quot;convert Greek text to uppercase&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;Χαίρετε&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;ΧΑΊΡΕΤΕ&quot;</span>;
});
<span class="cm-variable">test</span>(<span class="cm-string">&quot;don't convert case-less characters&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;مرحبا&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;مرحبا&quot;</span>;
});</pre>

<p>こんな風にテストを書くと、むしろしつこくてぎこちないコードになってしまう。幸い、テストの集合( <em>テストスイート</em> )を組み立てて実行するソフトウェアが存在する。それを使えば、テストを表現するのに適した言葉(関数やメソッドの形)で書けて、テストが失敗したときには意味のある情報をアウトプットしてくれる。これはたいてい <em>テストランナー</em> と呼ばれる。</p>

<p>あるコードが、他のコードよりテストしやすい、ということがある。一般的に、外部のオブジェクトとの関わりが多いコードほど、テストのための文脈のセットアップが大変になる。<a href="07_robot.html">前の章</a>で示したプログラミングのスタイル、つまり外部のオブジェクトを変更せずに自己完結した永続データを使うスタイルでは、テストが簡単になりやすい。</p>

<h2><a class="h_ident" id="h_k2QNrTrtgz" href="#h_k2QNrTrtgz" tabindex="-1" role="presentation"></a>デバッグ</h2>

<p>プログラムの挙動が変だったりエラーが出たりして、何かがおかしいと気づいたら、次のステップはその <em>何か</em> をつきとめることだ。</p>

<p>それが簡単な場合もある。エラーメッセージがプログラムのある行を指していて、エラーの説明とプログラムのその行を読めば分かってしまうような場合だ。</p>

<p>でも、いつでもそうなるとは限らない。問題が起こった行は、どこかで作られた壊れた値が、単に初めて使われただけの場合があるからだ。これまでの章のエクササイズを解いてきたなら、そういう状況を経験したことがあるだろう。</p>

<p><a class="p_ident" id="p_AGHCaI1vIH" href="#p_AGHCaI1vIH" tabindex="-1" role="presentation"></a>次の関数は、整数を、与えられた底(10進数、2進数などなど)で文字列に変換しようとする。繰返し最後の桁の数を取り出して、入力の数字を底で割ることでこの桁を捨てる。はずだけど、おかしな出力がバグの存在を示している。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8tOR9x4PzT" href="#c_8tOR9x4PzT" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">numberToString</span>(<span class="cm-def">n</span>, <span class="cm-def">base</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>, <span class="cm-def">sign</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">sign</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;-&quot;</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable-2">n</span>;
  }
  <span class="cm-keyword">do</span> {
    <span class="cm-variable-2">result</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">%</span> <span class="cm-variable-2">base</span>) <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">/=</span> <span class="cm-variable-2">base</span>;
  } <span class="cm-keyword">while</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">sign</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">numberToString</span>(<span class="cm-number">13</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3…</span></pre>

<p>既に問題が分かっていてもしばらく知らないフリをしてほしい。このプログラムが機能していないことは分かるけど、なぜかをつきとめていこう。</p>

<p>ここでランダムな変更を加えてよくなるかどうか見てみたい衝動に抵抗しよう。その代りに、 <em>考えるんだ</em> 。何が起こっているが分析して、どうしてそうなるのか理論を思いついてみよう。それから、その理論をテストするために追加で観察をしよう。あるいはまだ理論がないなら追加の観察によって何か思いつくかもしれない。</p>

<p>プログラムに戦略的に <code>console.log</code> を置いていくのも、プログラムの動作の情報を得るのにはいい戦略だ。この場合、 <code>n</code> の値が <code>13</code> , <code>1</code> , <code>0</code> と変化してほしい。ループの始めで <code>n</code> の値を書かせてみよう。</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_nB/OeL8UNa" href="#c_nB/OeL8UNa" tabindex="-1" role="presentation"></a>13
1.3
0.13
0.013
…
1.5e-323</pre>

<p><a class="p_ident" id="p_7GJjl4AIi9" href="#p_7GJjl4AIi9" tabindex="-1" role="presentation"></a><em>なるほど</em> 。13割る10が整数になっていない。 <code>n /= base</code> ではなくて、本当にほしいのは <code>n = Math.<wbr>floor(n /<wbr> base)</code> だ。こうすれば、桁がちゃんと右に &quot;シフトする&quot;。</p>

<p><a class="p_ident" id="p_qDI6Kps0rn" href="#p_qDI6Kps0rn" tabindex="-1" role="presentation"></a><code>console.log</code> 以外で、プログラムの挙動を調べる方法には、ブラウザーのデバッガー機能がある。ブラウザーには、コードの指定した場所にブレイクポイントを仕込む機能があるんだ。プログラムはブレイクポイントの行に達したら、一旦実行を停止するから、その時点でのバインディングの値を調べられる。デバッガーはブラウザーによってまちまちだからここでは詳しい話はしない。使っているブラウザーの開発者ツールを見たりやWebで調べてみたりするといい。</p>

<p>他にも <code>debugger</code> 宣言(単にこのキーワードだけの文)をプログラムに含めるとブレイクポイントを仕込むことができる。ブラウザーの開発者ツールがアクティブになっていれば、プログラムは <code>debugger</code> に到達したところで停止する。</p>

<h2><a class="h_ident" id="h_xV7f6EgZbK" href="#h_xV7f6EgZbK" tabindex="-1" role="presentation"></a>エラーの伝搬</h2>

<p>全ての問題がプログラマーによって防止できるわけではない、残念ながら。プログラムが外の世界とやりとりするなら、入力の形式がおかしいかもしれないし、過負荷状態になるかもしれないし、ネットワークの障害があるかもしれない。</p>

<p>プログラムが自分だけのものなら、そういう問題が起こるまで無視していてもいい。でも他の人も使うようなものを作るなら、単にクラッシュするよりはマシな対応をしたい。間違った入力を受け取ったとき、何も気にせず実行が続いた方がいい場合もあれば、ユーザーに問題を報告してギブアップした方がいい場合もある。ただ、どちらにしろプログラムは問題に対して主体的に対処するべきだ。</p>

<p><a class="p_ident" id="p_7w67t3KY4f" href="#p_7w67t3KY4f" tabindex="-1" role="presentation"></a>ユーザーに数字を要求して、それを返り値にする <code>promptNumber</code> という関数があるとしよう。ユーザーの入力が“orange”だったら何を返すべきだろう。</p>

<p><a class="p_ident" id="p_pD/MhHwik3" href="#p_pD/MhHwik3" tabindex="-1" role="presentation"></a>1つの選択肢としては、特別な値を返すことだ。一般的なのは <code>null</code> , <code>undefined</code> あるいは-1だ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ssOc2pf47/" href="#c_ssOc2pf47/" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">promptNumber</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable">Number</span>.<span class="cm-property">isNaN</span>(<span class="cm-variable-2">result</span>)) <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">promptNumber</span>(<span class="cm-string">&quot;How many trees do you see?&quot;</span>));</pre>

<p><code>promptNumber</code> を呼び出す関数は、本当の数字が返ってきたかチェックして、失敗だったらなんとかリカバーしないといけない。また聞いたり、デフォルト値で埋めたりすることになるだろう。もしくは、さらに <em>その</em> 呼び出し元に特別な値を返して、要求に失敗したと伝えるかだ。</p>

<p>たいていの状況で、特にエラーが起こりやすく呼び出し元がそれを計算に入れるべきときには、特別な値を返す事がエラーを示すには良い方法だ。とはいえ、ここには欠点もある。まず、そもそもの関数がどんな値でも返し得るものだったらどうだろう?そういう関数では成功と失敗を見分けるために、結果をオブジェクトに包むようなことをしないといけない。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_aQW8dfZcRx" href="#c_aQW8dfZcRx" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">lastElement</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">return</span> {<span class="cm-property">failed</span>: <span class="cm-atom">true</span>};
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> {<span class="cm-property">element</span>: <span class="cm-variable-2">array</span>[<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>]};
  }
}</pre>

<p><a class="p_ident" id="p_96uAUcJUq/" href="#p_96uAUcJUq/" tabindex="-1" role="presentation"></a>特別な値を返すことの2つ目の問題は、わずらわしいコードになりかねないことだ。あるコードが <code>promptNumber</code> を10回呼び出すなら <code>null</code> が返されていないか10回チェックすることになる。その上、 <code>null</code> を見つけたときの反応として、そのコードもまた <code>null</code> を返すなら、その呼び出し元がまたチェックしないといけない。</p>

<h2><a class="h_ident" id="h_j415hnLO9o" href="#h_j415hnLO9o" tabindex="-1" role="presentation"></a>例外(Exceptions)</h2>

<p><a class="p_ident" id="p_inz/P47QgH" href="#p_inz/P47QgH" tabindex="-1" role="presentation"></a>ある関数が通常通り実行を続けていけないときには、実行を止めて問題への対処方法が分かっている場所へすぐにジャンプできれば <em>うれしい</em> 。これが <em>例外処理(exception handling)</em> のすることだ。</p>

<p><a class="p_ident" id="p_Z9GcELQVxl" href="#p_Z9GcELQVxl" tabindex="-1" role="presentation"></a>例外とは、コードが問題にぶつかったときに例外を <em>発生させる(raise)</em> (もしくは <em>投げる(throw)</em> )メカニズムのことだ。例外はどういう値でも取り得る。例外を発生させるのは、関数からの超強力なreturnみたいなものだ。現在の関数だけではなく、その呼び出し元も飛び出して、実行が始まった初めの呼び出しまで戻る。これを <em>スタックの巻き戻し</em> という。<a href="03_functions.html#stack">3</a>章での関数呼び出しのスタックを覚えているだろう。例外はこのスタックを急降下していって、呼び出しのコンテキストを全て捨てていく。</p>

<p>もし例外が常にスタックの一番下まで急降下していくなら、あまり使い道はないだろう。ただプログラムの壊れ方が新しくなっただけだ。例外のパワーは、例外を <em>キャッチする</em> ためにスタックに障害物を置けるところにある。例外をキャッチしてしまえば、問題に対処するために何かしらできるし、プログラムの実行を継続できる。</p>

<p>これがその例だ。</p>

<pre id="look" class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0VA94HjY2e" href="#c_0VA94HjY2e" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;left&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;L&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;right&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;R&quot;</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Invalid direction: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}

<span class="cm-keyword">function</span> <span class="cm-def">look</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-variable">promptDirection</span>(<span class="cm-string">&quot;Which way?&quot;</span>) <span class="cm-operator">==</span> <span class="cm-string">&quot;L&quot;</span>) {
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;a house&quot;</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;two angry bears&quot;</span>;
  }
}

<span class="cm-keyword">try</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You see&quot;</span>, <span class="cm-variable">look</span>());
} <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Something went wrong: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
}</pre>

<p><code>throw</code> キーワードは例外を発生させるために使われる。例外をキャッチするにはコードを <code>try</code> ブロックで囲んで、 <code>catch</code> キーワードを続ければいい。 <code>try</code> ブロック内で例外が発生すれば、 <code>catch</code> ブロックが評価される。このとき、カッコ内の名前に例外値がバインドされる。 <code>catch</code> ブロックが終わるか、 <code>try</code> ブロックが問題なく終わるかすれば、 <code>try/catch</code> 宣言の次へプログラムは進んでいく。</p>

<p>上の例では <code>Error</code> コンストラクターでオリジナルの例外の値を作っている。これはJavaScript標準のコンストラクターで、 <code>message</code> プロパティを持つオブジェクトを作る。たいていのJavaScript実行環境では、このコンストラクターは例外が作られた瞬間のコールスタックの情報( <em>スタックトレース</em> )も収集する。この情報は <code>stack</code> プロパティに保存されて、デバッグの助けになる。問題の起こった関数や呼び出しを失敗した関数を教えてくれるからだ。</p>

<p><code>look</code> 関数では <code>promptDirection</code> が失敗する可能性を完全に無視しているしていることに注目してほしい。これが例外の大きなアドバンテージだ。エラーを処理するコードは、エラーが起こる場所とエラーを処理する場所でだけ必要になる。間にある関数はエラー処理のことはすっかり忘れていい。</p>

<p>いや、ほとんど忘れていい...</p>

<h2><a class="h_ident" id="h_rLog8qsr3q" href="#h_rLog8qsr3q" tabindex="-1" role="presentation"></a>例外後の片付け</h2>

<p>例外の効果は新しい種類の制御フローともいえる。例外を起こしかねないコードは全て、その時点のコードから制御を離脱させてしまうかもしれないからだ。ほとんど全ての関数の呼び出しやプロパティへのアクセスも例外を起こしかねないのだけど。</p>

<p>これは、コードにいくつか副作用がある場合には、一見その&quot;普通&quot;の制御フローが全て実行されるように見えても、例外がどこかで実行を妨げるかもしれないということだ。</p>

<p>以下はひどい銀行口座のコードだ。</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_e3XosnGG47" href="#c_e3XosnGG47" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">accounts</span> <span class="cm-operator">=</span> {
  <span class="cm-property">a</span>: <span class="cm-number">100</span>,
  <span class="cm-property">b</span>: <span class="cm-number">0</span>,
  <span class="cm-property">c</span>: <span class="cm-number">20</span>
};

<span class="cm-keyword">function</span> <span class="cm-def">getAccount</span>() {
  <span class="cm-keyword">let</span> <span class="cm-def">accountName</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-string">&quot;Enter an account name&quot;</span>);
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">accounts</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">accountName</span>)) {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string-2">`No such account: ${</span><span class="cm-variable-2">accountName</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">accountName</span>;
}

<span class="cm-keyword">function</span> <span class="cm-def">transfer</span>(<span class="cm-def">from</span>, <span class="cm-def">amount</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">&lt;</span> <span class="cm-variable-2">amount</span>) <span class="cm-keyword">return</span>;
  <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">-=</span> <span class="cm-variable-2">amount</span>;
  <span class="cm-variable">accounts</span>[<span class="cm-variable">getAccount</span>()] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
}</pre>

<p><a class="p_ident" id="p_lj3bgLcO/p" href="#p_lj3bgLcO/p" tabindex="-1" role="presentation"></a>The <code>transfer</code> function transfers a sum of money from a given account to another, asking for the name of the other account in the process. If given an invalid account name, <code>getAccount</code> throws an exception.</p>

<p><a class="p_ident" id="p_IvzAvOGwRo" href="#p_IvzAvOGwRo" tabindex="-1" role="presentation"></a>But <code>transfer</code> <em>first</em> removes the money from the account and <em>then</em> calls <code>getAccount</code> before it adds it to another account. If it is broken off by an exception at that point, it’ll just make the money disappear.</p>

<p><a class="p_ident" id="p_vSkNwpOGmb" href="#p_vSkNwpOGmb" tabindex="-1" role="presentation"></a>That code could have been written a little more intelligently, for example by calling <code>getAccount</code> before it starts moving money around. But often problems like this occur in more subtle ways. Even functions that don’t look like they will throw an exception might do so in exceptional circumstances or when they contain a programmer mistake.</p>

<p><a class="p_ident" id="p_6ijkWjygkN" href="#p_6ijkWjygkN" tabindex="-1" role="presentation"></a>One way to address this is to use fewer side effects. Again, a programming style that computes new values instead of changing existing data helps. If a piece of code stops running in the middle of creating a new value, no one ever sees the half-finished value, and there is no problem.</p>

<p><a class="p_ident" id="p_lhrnmP99dZ" href="#p_lhrnmP99dZ" tabindex="-1" role="presentation"></a>But that isn’t always practical. So there is another feature that <code>try</code> statements have. They may be followed by a <code>finally</code> block either instead of or in addition to a <code>catch</code> block. A <code>finally</code> block says “no matter <em>what</em> happens, run this code after trying to run the code in the <code>try</code> block.”</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_brWpzDAy4+" href="#c_brWpzDAy4+" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">transfer</span>(<span class="cm-def">from</span>, <span class="cm-def">amount</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">&lt;</span> <span class="cm-variable-2">amount</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">progress</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">-=</span> <span class="cm-variable-2">amount</span>;
    <span class="cm-variable-2">progress</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
    <span class="cm-variable">accounts</span>[<span class="cm-variable">getAccount</span>()] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
    <span class="cm-variable-2">progress</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>;
  } <span class="cm-keyword">finally</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">progress</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
    }
  }
}</pre>

<p><a class="p_ident" id="p_LvvK85Vh5F" href="#p_LvvK85Vh5F" tabindex="-1" role="presentation"></a>This version of the function tracks its progress, and if, when leaving, it notices that it was aborted at a point where it had created an inconsistent program state, it repairs the damage it did.</p>

<p><a class="p_ident" id="p_Gs19OQg3TY" href="#p_Gs19OQg3TY" tabindex="-1" role="presentation"></a>Note that even though the <code>finally</code> code is run when an exception is thrown in the <code>try</code> block, it does not interfere with the exception. After the <code>finally</code> block runs, the stack continues unwinding.</p>

<p><a class="p_ident" id="p_yZkXySCQHr" href="#p_yZkXySCQHr" tabindex="-1" role="presentation"></a>Writing programs that operate reliably even when exceptions pop up in unexpected places is hard. Many people simply don’t bother, and because exceptions are typically reserved for exceptional circumstances, the problem may occur so rarely that it is never even noticed. Whether that is a good thing or a really bad thing depends on how much damage the software will do when it fails.</p>

<h2><a class="h_ident" id="h_vfoJqEDazI" href="#h_vfoJqEDazI" tabindex="-1" role="presentation"></a>Selective catching</h2>

<p><a class="p_ident" id="p_HUJ9GRG1jC" href="#p_HUJ9GRG1jC" tabindex="-1" role="presentation"></a>When an exception makes it all the way to the bottom of the stack without being caught, it gets handled by the environment. What this means differs between environments. In browsers, a description of the error typically gets written to the JavaScript console (reachable through the browser’s Tools or Developer menu). Node.js, the browserless JavaScript environment we will discuss in <a href="20_node.html">Chapter 20</a>, is more careful about data corruption. It aborts the whole process when an unhandled exception occurs.</p>

<p><a class="p_ident" id="p_9JOlpepKZE" href="#p_9JOlpepKZE" tabindex="-1" role="presentation"></a>For programmer mistakes, just letting the error go through is often the best you can do. An unhandled exception is a reasonable way to signal a broken program, and the JavaScript console will, on modern browsers, provide you with some information about which function calls were on the stack when the problem occurred.</p>

<p><a class="p_ident" id="p_KGWPPf4CcF" href="#p_KGWPPf4CcF" tabindex="-1" role="presentation"></a>For problems that are <em>expected</em> to happen during routine use, crashing with an unhandled exception is a terrible strategy.</p>

<p><a class="p_ident" id="p_ZkwQ40b3to" href="#p_ZkwQ40b3to" tabindex="-1" role="presentation"></a>Invalid uses of the language, such as referencing a nonexistent binding, looking up a property on <code>null</code>, or calling something that’s not a function, will also result in exceptions being raised. Such exceptions can also be caught.</p>

<p><a class="p_ident" id="p_8IwJJBHBTh" href="#p_8IwJJBHBTh" tabindex="-1" role="presentation"></a>When a <code>catch</code> body is entered, all we know is that <em>something</em> in our <code>try</code> body caused an exception. But we don’t know <em>what</em> did or <em>which</em> exception it caused.</p>

<p><a class="p_ident" id="p_3umLtBJgPo" href="#p_3umLtBJgPo" tabindex="-1" role="presentation"></a>JavaScript (in a rather glaring omission) doesn’t provide direct support for selectively catching exceptions: either you catch them all or you don’t catch any. This makes it tempting to <em>assume</em> that the exception you get is the one you were thinking about when you wrote the <code>catch</code> block.</p>

<p><a class="p_ident" id="p_O9bj9nd33p" href="#p_O9bj9nd33p" tabindex="-1" role="presentation"></a>But it might not be. Some other assumption might be violated, or you might have introduced a bug that is causing an exception. Here is an example that <em>attempts</em> to keep on calling <code>promptDirection</code> until it gets a valid answer:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZxDKrGLCQ3" href="#c_ZxDKrGLCQ3" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promtDirection</span>(<span class="cm-string">&quot;Where?&quot;</span>); <span class="cm-comment">// ← typo!</span>
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You chose &quot;</span>, <span class="cm-variable-2">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Not a valid direction. Try again.&quot;</span>);
  }
}</pre>

<p><a class="p_ident" id="p_pdL8VKiwnf" href="#p_pdL8VKiwnf" tabindex="-1" role="presentation"></a>The <code>for (;;)</code> construct is a way to intentionally create a loop that doesn’t terminate on its own. We break out of the loop only when a valid direction is given. <em>But</em> we misspelled <code>promptDirection</code>, which will result in an “undefined variable” error. Because the <code>catch</code> block completely ignores its exception value (<code>e</code>), assuming it knows what the problem is, it wrongly treats the binding error as indicating bad input. Not only does this cause an infinite loop, it “buries” the useful error message about the misspelled binding.</p>

<p><a class="p_ident" id="p_hk/lwBIhah" href="#p_hk/lwBIhah" tabindex="-1" role="presentation"></a>As a general rule, don’t blanket-catch exceptions unless it is for the purpose of “routing” them somewhere—for example, over the network to tell another system that our program crashed. And even then, think carefully about how you might be hiding information.</p>

<p><a class="p_ident" id="p_o1E5pkUD5g" href="#p_o1E5pkUD5g" tabindex="-1" role="presentation"></a>So we want to catch a <em>specific</em> kind of exception. We can do this by checking in the <code>catch</code> block whether the exception we got is the one we are interested in and rethrowing it otherwise. But how do we recognize an exception?</p>

<p><a class="p_ident" id="p_qurSIk3pjE" href="#p_qurSIk3pjE" tabindex="-1" role="presentation"></a>We could compare its <code>message</code> property against the error message we happen to expect. But that’s a shaky way to write code—we’d be using information that’s intended for human consumption (the message) to make a programmatic decision. As soon as someone changes (or translates) the message, the code will stop working.</p>

<p><a class="p_ident" id="p_Pml4dAzuT1" href="#p_Pml4dAzuT1" tabindex="-1" role="presentation"></a>Rather, let’s define a new type of error and use <code>instanceof</code> to identify it.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_miFD8lvrWj" href="#c_miFD8lvrWj" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">InputError</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;left&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;L&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;right&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;R&quot;</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">InputError</span>(<span class="cm-string">&quot;Invalid direction: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}</pre>

<p><a class="p_ident" id="p_/YM4ZmoOGt" href="#p_/YM4ZmoOGt" tabindex="-1" role="presentation"></a>The new error class extends <code>Error</code>. It doesn’t define its own constructor, which means that it inherits the <code>Error</code> constructor, which expects a string message as argument. In fact, it doesn’t define anything at all—the class is empty. <code>InputError</code> objects behave like <code>Error</code> objects, except that they have a different class by which we can recognize them.</p>

<p><a class="p_ident" id="p_JqyLwQxCGY" href="#p_JqyLwQxCGY" tabindex="-1" role="presentation"></a>Now the loop can catch these more carefully.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ab/mR1C1nr" href="#c_ab/mR1C1nr" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promptDirection</span>(<span class="cm-string">&quot;Where?&quot;</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You chose &quot;</span>, <span class="cm-variable-2">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">InputError</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Not a valid direction. Try again.&quot;</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">throw</span> <span class="cm-variable-2">e</span>;
    }
  }
}</pre>

<p><a class="p_ident" id="p_N4ExnmZrQ/" href="#p_N4ExnmZrQ/" tabindex="-1" role="presentation"></a>This will catch only instances of <code>InputError</code> and let unrelated exceptions through. If you reintroduce the typo, the undefined binding error will be properly reported.</p>

<h2><a class="h_ident" id="h_Sb9V3BEus1" href="#h_Sb9V3BEus1" tabindex="-1" role="presentation"></a>Assertions</h2>

<p><a class="p_ident" id="p_Is9Zkz2o9G" href="#p_Is9Zkz2o9G" tabindex="-1" role="presentation"></a><em>Assertions</em> are checks inside a program that verify that something is the way it is supposed to be. They are used not to handle situations that can come up in normal operation but to find programmer mistakes.</p>

<p><a class="p_ident" id="p_uMhd4mC7ZW" href="#p_uMhd4mC7ZW" tabindex="-1" role="presentation"></a>If, for example, <code>firstElement</code> is described as a function that should never be called on empty arrays, we might write it like this:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gRlHo3tyh8" href="#c_gRlHo3tyh8" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">firstElement</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;firstElement called with []&quot;</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>[<span class="cm-number">0</span>];
}</pre>

<p><a class="p_ident" id="p_MOw81C4a4b" href="#p_MOw81C4a4b" tabindex="-1" role="presentation"></a>Now, instead of silently returning undefined (which you get when reading an array property that does not exist), this will loudly blow up your program as soon as you misuse it. This makes it less likely for such mistakes to go unnoticed and easier to find their cause when they occur.</p>

<p><a class="p_ident" id="p_bFN2bXWxAz" href="#p_bFN2bXWxAz" tabindex="-1" role="presentation"></a>I do not recommend trying to write assertions for every possible kind of bad input. That’d be a lot of work and would lead to very noisy code. You’ll want to reserve them for mistakes that are easy to make (or that you find yourself making).</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>Summary</h2>

<p><a class="p_ident" id="p_rD8/ab0/w4" href="#p_rD8/ab0/w4" tabindex="-1" role="presentation"></a>Mistakes and bad input are facts of life. An important part of programming is finding, diagnosing, and fixing bugs. Problems can become easier to notice if you have an automated test suite or add assertions to your programs.</p>

<p><a class="p_ident" id="p_8tal4BvCRU" href="#p_8tal4BvCRU" tabindex="-1" role="presentation"></a>Problems caused by factors outside the program’s control should usually be handled gracefully. Sometimes, when the problem can be handled locally, special return values are a good way to track them. Otherwise, exceptions may be preferable.</p>

<p><a class="p_ident" id="p_ZJkq9NFh8W" href="#p_ZJkq9NFh8W" tabindex="-1" role="presentation"></a>Throwing an exception causes the call stack to be unwound until the next enclosing <code>try/catch</code> block or until the bottom of the stack. The exception value will be given to the <code>catch</code> block that catches it, which should verify that it is actually the expected kind of exception and then do something with it. To help address the unpredictable control flow caused by exceptions, <code>finally</code> blocks can be used to ensure that a piece of code <em>always</em> runs when a block finishes.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>Exercises</h2>

<h3><a class="i_ident" id="i_n1zYouiAfX" href="#i_n1zYouiAfX" tabindex="-1" role="presentation"></a>Retry</h3>

<p><a class="p_ident" id="p_oAuWXajIJA" href="#p_oAuWXajIJA" tabindex="-1" role="presentation"></a>Say you have a function <code>primitiveMultiply</code> that in 20 percent of cases multiplies two numbers and in the other 80 percent of cases raises an exception of type <code>MultiplicatorUnitFailure</code>. Write a function that wraps this clunky function and just keeps trying until a call succeeds, after which it returns the result.</p>

<p><a class="p_ident" id="p_FfNd4pOv0L" href="#p_FfNd4pOv0L" tabindex="-1" role="presentation"></a>Make sure you handle only the exceptions you are trying to handle.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_E1Acr2VS8k" href="#c_E1Acr2VS8k" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">MultiplicatorUnitFailure</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">primitiveMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">&lt;</span> <span class="cm-number">0.2</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">MultiplicatorUnitFailure</span>(<span class="cm-string">&quot;Klunk&quot;</span>);
  }
}

<span class="cm-keyword">function</span> <span class="cm-def">reliableMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reliableMultiply</span>(<span class="cm-number">8</span>, <span class="cm-number">8</span>));
<span class="cm-comment">// → 64</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_ChowJFeR1F" href="#p_ChowJFeR1F" tabindex="-1" role="presentation"></a>The call to <code>primitiveMultiply</code> should definitely happen in a <code>try</code> block. The corresponding <code>catch</code> block should rethrow the exception when it is not an instance of <code>MultiplicatorUnitFailure</code> and ensure the call is retried when it is.</p>

<p><a class="p_ident" id="p_2LqwPbYM+K" href="#p_2LqwPbYM+K" tabindex="-1" role="presentation"></a>To do the retrying, you can either use a loop that stops only when a call succeeds—as in the <a href="08_error.html#look"><code>look</code> example</a> earlier in this chapter—or use recursion and hope you don’t get a string of failures so long that it overflows the stack (which is a pretty safe bet).</p>

</div></div>

<h3><a class="i_ident" id="i_iGlwnUbkRs" href="#i_iGlwnUbkRs" tabindex="-1" role="presentation"></a>The locked box</h3>

<p><a class="p_ident" id="p_uGznOGuYh8" href="#p_uGznOGuYh8" tabindex="-1" role="presentation"></a>Consider the following (rather contrived) object:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_X963W9SHCK" href="#c_X963W9SHCK" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">box</span> <span class="cm-operator">=</span> {
  <span class="cm-property">locked</span>: <span class="cm-atom">true</span>,
  <span class="cm-property">unlock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>; },
  <span class="cm-property">lock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;  },
  <span class="cm-property">_content</span>: [],
  <span class="cm-property">get</span> <span class="cm-property">content</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">locked</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Locked!&quot;</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">_content</span>;
  }
};</pre>

<p><a class="p_ident" id="p_PPjq8MDhzp" href="#p_PPjq8MDhzp" tabindex="-1" role="presentation"></a>It is a box with a lock. There is an array in the box, but you can get at it only when the box is unlocked. Directly accessing the private <code>_content</code> property is forbidden.</p>

<p><a class="p_ident" id="p_KI+tJ+amDX" href="#p_KI+tJ+amDX" tabindex="-1" role="presentation"></a>Write a function called <code>withBoxUnlocked</code> that takes a function value as argument, unlocks the box, runs the function, and then ensures that the box is locked again before returning, regardless of whether the argument function returned normally or threw an exception.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EPN4Aey63n" href="#c_EPN4Aey63n" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">box</span> <span class="cm-operator">=</span> {
  <span class="cm-property">locked</span>: <span class="cm-atom">true</span>,
  <span class="cm-property">unlock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>; },
  <span class="cm-property">lock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;  },
  <span class="cm-property">_content</span>: [],
  <span class="cm-property">get</span> <span class="cm-property">content</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">locked</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Locked!&quot;</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">_content</span>;
  }
};

<span class="cm-keyword">function</span> <span class="cm-def">withBoxUnlocked</span>(<span class="cm-def">body</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">box</span>.<span class="cm-property">content</span>.<span class="cm-property">push</span>(<span class="cm-string">&quot;gold piece&quot;</span>);
});

<span class="cm-keyword">try</span> {
  <span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Pirates on the horizon! Abort!&quot;</span>);
  });
} <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Error raised: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">e</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">box</span>.<span class="cm-property">locked</span>);
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_X5dxXtnN4l" href="#p_X5dxXtnN4l" tabindex="-1" role="presentation"></a>For extra points, make sure that if you call <code>withBoxUnlocked</code> when the box is already unlocked, the box stays unlocked.</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_4MxgD1VcbV" href="#p_4MxgD1VcbV" tabindex="-1" role="presentation"></a>This exercise calls for a <code>finally</code> block. Your function should first unlock the box and then call the argument function from inside a <code>try</code> body. The <code>finally</code> block after it should lock the box again.</p>

<p><a class="p_ident" id="p_PvZL0oQnMG" href="#p_PvZL0oQnMG" tabindex="-1" role="presentation"></a>To make sure we don’t lock the box when it wasn’t already locked, check its lock at the start of the function and unlock and lock it only when it started out locked.</p>

</div></div><nav><a href="07_robot.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="09_regexp.html" title="next chapter">▶</a></nav>
</article>
